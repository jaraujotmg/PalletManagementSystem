Source Code Concatenation Report
Project Root: D:\source\PalletManagementSystem\src\PalletManagementSystem.Core
Generated On: 04/01/2025 17:17:05
Included Extensions: .cs, .vb, .fs, .cpp, .c, .hpp, .h, .js, .ts, .jsx, .tsx, .html, .htm, .css, .scss, .less, .xaml, .razor, .cshtml, .sql, .py, .sh, .ps1, .xml, .json, .yaml, .yml, .config, .settings, .props, .targets
Excluded Directories: bin, obj, .vs, .git, .svn, node_modules, packages, TestResults, GeneratedFiles



===============================================================================
File: DTOs\ClientDto.cs
===============================================================================
namespace PalletManagementSystem.Core.DTOs
{
    /// <summary>
    /// Data transfer object for a client
    /// </summary>
    public class ClientDto
    {
        /// <summary>
        /// Gets or sets the client code
        /// </summary>
        public string ClientCode { get; set; }

        /// <summary>
        /// Gets or sets the client name
        /// </summary>
        public string ClientName { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this is a special client
        /// </summary>
        public bool IsSpecial { get; set; }

        /// <summary>
        /// Gets or sets the number of items for this client
        /// </summary>
        public int ItemCount { get; set; }
    }
}

===============================================================================
File: DTOs\ItemDetailDto.cs
===============================================================================
using System;

namespace PalletManagementSystem.Core.DTOs
{
    /// <summary>
    /// DTO for item detail view (with pallet information)
    /// </summary>
    public class ItemDetailDto
    {
        /// <summary>
        /// Gets or sets the item ID
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// Gets or sets the item number
        /// </summary>
        public string ItemNumber { get; set; }

        /// <summary>
        /// Gets or sets the pallet ID
        /// </summary>
        public int PalletId { get; set; }

        /// <summary>
        /// Gets or sets the manufacturing order
        /// </summary>
        public string ManufacturingOrder { get; set; }

        /// <summary>
        /// Gets or sets the manufacturing order line
        /// </summary>
        public string ManufacturingOrderLine { get; set; }

        /// <summary>
        /// Gets or sets the service order
        /// </summary>
        public string ServiceOrder { get; set; }

        /// <summary>
        /// Gets or sets the service order line
        /// </summary>
        public string ServiceOrderLine { get; set; }

        /// <summary>
        /// Gets or sets the final order
        /// </summary>
        public string FinalOrder { get; set; }

        /// <summary>
        /// Gets or sets the final order line
        /// </summary>
        public string FinalOrderLine { get; set; }

        /// <summary>
        /// Gets or sets the client code
        /// </summary>
        public string ClientCode { get; set; }

        /// <summary>
        /// Gets or sets the client name
        /// </summary>
        public string ClientName { get; set; }

        /// <summary>
        /// Gets or sets the reference
        /// </summary>
        public string Reference { get; set; }

        /// <summary>
        /// Gets or sets the finish
        /// </summary>
        public string Finish { get; set; }

        /// <summary>
        /// Gets or sets the color
        /// </summary>
        public string Color { get; set; }

        /// <summary>
        /// Gets or sets the quantity
        /// </summary>
        public decimal Quantity { get; set; }

        /// <summary>
        /// Gets or sets the quantity unit
        /// </summary>
        public string QuantityUnit { get; set; }

        /// <summary>
        /// Gets or sets the weight
        /// </summary>
        public decimal Weight { get; set; }

        /// <summary>
        /// Gets or sets the weight unit
        /// </summary>
        public string WeightUnit { get; set; }

        /// <summary>
        /// Gets or sets the width
        /// </summary>
        public decimal Width { get; set; }

        /// <summary>
        /// Gets or sets the width unit
        /// </summary>
        public string WidthUnit { get; set; }

        /// <summary>
        /// Gets or sets the quality
        /// </summary>
        public string Quality { get; set; }

        /// <summary>
        /// Gets or sets the batch
        /// </summary>
        public string Batch { get; set; }

        /// <summary>
        /// Gets or sets the date when this item was created
        /// </summary>
        public DateTime CreatedDate { get; set; }

        /// <summary>
        /// Gets or sets the username of the creator
        /// </summary>
        public string CreatedBy { get; set; }

        /// <summary>
        /// Gets or sets basic pallet information
        /// </summary>
        public PalletInfo Pallet { get; set; }
    }

    /// <summary>
    /// Basic pallet information for item detail view
    /// </summary>
    public class PalletInfo
    {
        /// <summary>
        /// Gets or sets the pallet ID
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// Gets or sets the pallet number
        /// </summary>
        public string PalletNumber { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this pallet is closed
        /// </summary>
        public bool IsClosed { get; set; }
    }
}

===============================================================================
File: DTOs\ItemDto.cs
===============================================================================
using System;

namespace PalletManagementSystem.Core.DTOs
{
    /// <summary>
    /// Data transfer object for an item
    /// </summary>
    public class ItemDto
    {
        /// <summary>
        /// Gets or sets the item ID
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// Gets or sets the item number
        /// </summary>
        public string ItemNumber { get; set; }

        /// <summary>
        /// Gets or sets the pallet ID
        /// </summary>
        public int PalletId { get; set; }

        /// <summary>
        /// Gets or sets the manufacturing order
        /// </summary>
        public string ManufacturingOrder { get; set; }

        /// <summary>
        /// Gets or sets the manufacturing order line
        /// </summary>
        public string ManufacturingOrderLine { get; set; }

        /// <summary>
        /// Gets or sets the service order
        /// </summary>
        public string ServiceOrder { get; set; }

        /// <summary>
        /// Gets or sets the service order line
        /// </summary>
        public string ServiceOrderLine { get; set; }

        /// <summary>
        /// Gets or sets the final order
        /// </summary>
        public string FinalOrder { get; set; }

        /// <summary>
        /// Gets or sets the final order line
        /// </summary>
        public string FinalOrderLine { get; set; }

        /// <summary>
        /// Gets or sets the client code
        /// </summary>
        public string ClientCode { get; set; }

        /// <summary>
        /// Gets or sets the client name
        /// </summary>
        public string ClientName { get; set; }

        /// <summary>
        /// Gets or sets the reference
        /// </summary>
        public string Reference { get; set; }

        /// <summary>
        /// Gets or sets the finish
        /// </summary>
        public string Finish { get; set; }

        /// <summary>
        /// Gets or sets the color
        /// </summary>
        public string Color { get; set; }

        /// <summary>
        /// Gets or sets the quantity
        /// </summary>
        public decimal Quantity { get; set; }

        /// <summary>
        /// Gets or sets the quantity unit
        /// </summary>
        public string QuantityUnit { get; set; }

        /// <summary>
        /// Gets or sets the weight
        /// </summary>
        public decimal Weight { get; set; }

        /// <summary>
        /// Gets or sets the weight unit
        /// </summary>
        public string WeightUnit { get; set; }

        /// <summary>
        /// Gets or sets the width
        /// </summary>
        public decimal Width { get; set; }

        /// <summary>
        /// Gets or sets the width unit
        /// </summary>
        public string WidthUnit { get; set; }

        /// <summary>
        /// Gets or sets the quality
        /// </summary>
        public string Quality { get; set; }

        /// <summary>
        /// Gets or sets the batch
        /// </summary>
        public string Batch { get; set; }

        /// <summary>
        /// Gets or sets the date when this item was created
        /// </summary>
        public DateTime CreatedDate { get; set; }

        /// <summary>
        /// Gets or sets the username of the creator
        /// </summary>
        public string CreatedBy { get; set; }

        /// <summary>
        /// Gets or sets the pallet this item belongs to
        /// </summary>
        public PalletDto Pallet { get; set; }
    }
}

===============================================================================
File: DTOs\ItemListDto.cs
===============================================================================
using System;

namespace PalletManagementSystem.Core.DTOs
{
    /// <summary>
    /// DTO for item list view (without pallet)
    /// </summary>
    public class ItemListDto
    {
        /// <summary>
        /// Gets or sets the item ID
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// Gets or sets the item number
        /// </summary>
        public string ItemNumber { get; set; }

        /// <summary>
        /// Gets or sets the pallet ID
        /// </summary>
        public int PalletId { get; set; }

        /// <summary>
        /// Gets or sets the manufacturing order
        /// </summary>
        public string ManufacturingOrder { get; set; }

        /// <summary>
        /// Gets or sets the client code
        /// </summary>
        public string ClientCode { get; set; }

        /// <summary>
        /// Gets or sets the client name
        /// </summary>
        public string ClientName { get; set; }

        /// <summary>
        /// Gets or sets the quantity
        /// </summary>
        public decimal Quantity { get; set; }

        /// <summary>
        /// Gets or sets the quantity unit
        /// </summary>
        public string QuantityUnit { get; set; }

        /// <summary>
        /// Gets or sets the weight
        /// </summary>
        public decimal Weight { get; set; }

        /// <summary>
        /// Gets or sets the weight unit
        /// </summary>
        public string WeightUnit { get; set; }

        /// <summary>
        /// Gets or sets the width
        /// </summary>
        public decimal Width { get; set; }

        /// <summary>
        /// Gets or sets the width unit
        /// </summary>
        public string WidthUnit { get; set; }

        /// <summary>
        /// Gets or sets the date when this item was created
        /// </summary>
        public DateTime CreatedDate { get; set; }
    }
}

===============================================================================
File: DTOs\PagedResultDto.cs
===============================================================================
using System.Collections.Generic;

namespace PalletManagementSystem.Core.DTOs
{
    /// <summary>
    /// Data transfer object for a paged result
    /// </summary>
    /// <typeparam name="T">The type of items in the page</typeparam>
    public class PagedResultDto<T>
    {
        /// <summary>
        /// Gets or sets the items in the current page
        /// </summary>
        public IEnumerable<T> Items { get; set; }

        /// <summary>
        /// Gets or sets the total count of items across all pages
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// Gets or sets the current page number (1-based)
        /// </summary>
        public int PageNumber { get; set; }

        /// <summary>
        /// Gets or sets the page size
        /// </summary>
        public int PageSize { get; set; }

        /// <summary>
        /// Gets the total number of pages
        /// </summary>
        public int TotalPages => (PageSize <= 0) ? 0 : (TotalCount + PageSize - 1) / PageSize;

        /// <summary>
        /// Gets a value indicating whether there is a previous page
        /// </summary>
        public bool HasPreviousPage => PageNumber > 1;

        /// <summary>
        /// Gets a value indicating whether there is a next page
        /// </summary>
        public bool HasNextPage => PageNumber < TotalPages;
    }
}

===============================================================================
File: DTOs\PalletDetailDto.cs
===============================================================================
// src/PalletManagementSystem.Core/DTOs/PalletDetailDto.cs
using System;
using System.Collections.Generic;

namespace PalletManagementSystem.Core.DTOs
{
    /// <summary>
    /// DTO for pallet detail view (with detailed item information)
    /// </summary>
    public class PalletDetailDto
    {
        /// <summary>
        /// Gets or sets the pallet ID
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// Gets or sets the pallet number
        /// </summary>
        public string PalletNumber { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this pallet has a temporary number
        /// </summary>
        public bool IsTemporary { get; set; }

        /// <summary>
        /// Gets or sets the manufacturing order
        /// </summary>
        public string ManufacturingOrder { get; set; }

        /// <summary>
        /// Gets or sets the division
        /// </summary>
        public string Division { get; set; }

        /// <summary>
        /// Gets or sets the platform
        /// </summary>
        public string Platform { get; set; }

        /// <summary>
        /// Gets or sets the unit of measure
        /// </summary>
        public string UnitOfMeasure { get; set; }

        /// <summary>
        /// Gets or sets the quantity
        /// </summary>
        public decimal Quantity { get; set; }

        /// <summary>
        /// Gets or sets the number of items on this pallet
        /// </summary>
        public int ItemCount { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this pallet is closed
        /// </summary>
        public bool IsClosed { get; set; }

        /// <summary>
        /// Gets or sets the date when this pallet was created
        /// </summary>
        public DateTime CreatedDate { get; set; }

        /// <summary>
        /// Gets or sets the date when this pallet was closed
        /// </summary>
        public DateTime? ClosedDate { get; set; }

        /// <summary>
        /// Gets or sets the username of the creator
        /// </summary>
        public string CreatedBy { get; set; }

        // --- MODIFIED PROPERTY TYPE ---
        /// <summary>
        /// Gets or sets the detailed items on this pallet
        /// </summary>
        public ICollection<ItemDetailDto> Items { get; set; } = new List<ItemDetailDto>();
        // ------------------------------
    }
}

===============================================================================
File: DTOs\PalletDto.cs
===============================================================================
using System;
using System.Collections.Generic;

namespace PalletManagementSystem.Core.DTOs
{
    /// <summary>
    /// Data transfer object for a pallet
    /// </summary>
    public class PalletDto
    {
        /// <summary>
        /// Gets or sets the pallet ID
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// Gets or sets the pallet number
        /// </summary>
        public string PalletNumber { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this pallet has a temporary number
        /// </summary>
        public bool IsTemporary { get; set; }

        /// <summary>
        /// Gets or sets the manufacturing order
        /// </summary>
        public string ManufacturingOrder { get; set; }

        /// <summary>
        /// Gets or sets the division
        /// </summary>
        public string Division { get; set; }

        /// <summary>
        /// Gets or sets the platform
        /// </summary>
        public string Platform { get; set; }

        /// <summary>
        /// Gets or sets the unit of measure
        /// </summary>
        public string UnitOfMeasure { get; set; }

        /// <summary>
        /// Gets or sets the quantity
        /// </summary>
        public decimal Quantity { get; set; }

        /// <summary>
        /// Gets or sets the number of items on this pallet
        /// </summary>
        public int ItemCount { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this pallet is closed
        /// </summary>
        public bool IsClosed { get; set; }

        /// <summary>
        /// Gets or sets the date when this pallet was created
        /// </summary>
        public DateTime CreatedDate { get; set; }

        /// <summary>
        /// Gets or sets the date when this pallet was closed
        /// </summary>
        public DateTime? ClosedDate { get; set; }

        /// <summary>
        /// Gets or sets the username of the creator
        /// </summary>
        public string CreatedBy { get; set; }

        /// <summary>
        /// Gets or sets the items on this pallet
        /// </summary>
        public ICollection<ItemDto> Items { get; set; }
    }
}

===============================================================================
File: DTOs\PalletListDto.cs
===============================================================================
using System;

namespace PalletManagementSystem.Core.DTOs
{
    /// <summary>
    /// DTO for pallet list view (without items)
    /// </summary>
    public class PalletListDto
    {
        /// <summary>
        /// Gets or sets the pallet ID
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// Gets or sets the pallet number
        /// </summary>
        public string PalletNumber { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this pallet has a temporary number
        /// </summary>
        public bool IsTemporary { get; set; }

        /// <summary>
        /// Gets or sets the manufacturing order
        /// </summary>
        public string ManufacturingOrder { get; set; }

        /// <summary>
        /// Gets or sets the division
        /// </summary>
        public string Division { get; set; }

        /// <summary>
        /// Gets or sets the platform
        /// </summary>
        public string Platform { get; set; }

        /// <summary>
        /// Gets or sets the unit of measure
        /// </summary>
        public string UnitOfMeasure { get; set; }

        /// <summary>
        /// Gets or sets the quantity
        /// </summary>
        public decimal Quantity { get; set; }

        /// <summary>
        /// Gets or sets the number of items on this pallet
        /// </summary>
        public int ItemCount { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this pallet is closed
        /// </summary>
        public bool IsClosed { get; set; }

        /// <summary>
        /// Gets or sets the date when this pallet was created
        /// </summary>
        public DateTime CreatedDate { get; set; }

        /// <summary>
        /// Gets or sets the date when this pallet was closed
        /// </summary>
        public DateTime? ClosedDate { get; set; }

        /// <summary>
        /// Gets or sets the username of the creator
        /// </summary>
        public string CreatedBy { get; set; }
    }
}

===============================================================================
File: DTOs\SearchResultDto.cs
===============================================================================
namespace PalletManagementSystem.Core.DTOs
{
    /// <summary>
    /// Data transfer object for a search result
    /// </summary>
    public class SearchResultDto
    {
        /// <summary>
        /// Gets or sets the ID of the entity
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// Gets or sets the type of entity (e.g., "Pallet", "Item")
        /// </summary>
        public string EntityType { get; set; }

        /// <summary>
        /// Gets or sets the primary identifier (e.g., pallet number, item number)
        /// </summary>
        public string Identifier { get; set; }

        /// <summary>
        /// Gets or sets the additional information (e.g., manufacturing order)
        /// </summary>
        public string AdditionalInfo { get; set; }

        /// <summary>
        /// Gets or sets the URL to view the entity
        /// </summary>
        public string ViewUrl { get; set; }
    }
}

===============================================================================
File: DTOs\SearchSuggestionDto.cs
===============================================================================
namespace PalletManagementSystem.Core.DTOs
{
    /// <summary>
    /// Data transfer object for a search suggestion
    /// </summary>
    public class SearchSuggestionDto
    {
        /// <summary>
        /// Gets or sets the suggestion text
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// Gets or sets the type of suggestion (e.g., "Pallet", "Item", "Order")
        /// </summary>
        public string Type { get; set; }

        /// <summary>
        /// Gets or sets the URL for the suggestion if selected
        /// </summary>
        public string Url { get; set; }

        /// <summary>
        /// Gets or sets the ID of the entity
        /// </summary>
        public int? EntityId { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this is a "view all" suggestion
        /// </summary>
        public bool IsViewAll { get; set; }
    }
}

===============================================================================
File: DTOs\UpdateItemDto.cs
===============================================================================
namespace PalletManagementSystem.Core.DTOs
{
    /// <summary>
    /// DTO for updating an item's editable properties
    /// </summary>
    public class UpdateItemDto
    {
        /// <summary>
        /// Gets or sets the weight
        /// </summary>
        public decimal Weight { get; set; }

        /// <summary>
        /// Gets or sets the width
        /// </summary>
        public decimal Width { get; set; }

        /// <summary>
        /// Gets or sets the quality
        /// </summary>
        public string Quality { get; set; }

        /// <summary>
        /// Gets or sets the batch
        /// </summary>
        public string Batch { get; set; }
    }
}

===============================================================================
File: DTOs\UserPreferencesDto.cs
===============================================================================
namespace PalletManagementSystem.Core.DTOs
{
    /// <summary>
    /// Data transfer object for user preferences
    /// </summary>
    public class UserPreferencesDto
    {
        /// <summary>
        /// Gets or sets the username
        /// </summary>
        public string Username { get; set; }

        /// <summary>
        /// Gets or sets the preferred division
        /// </summary>
        public string PreferredDivision { get; set; }

        /// <summary>
        /// Gets or sets the preferred platform
        /// </summary>
        public string PreferredPlatform { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether touch mode is enabled
        /// </summary>
        public bool TouchModeEnabled { get; set; }

        /// <summary>
        /// Gets or sets the number of items per page
        /// </summary>
        public int ItemsPerPage { get; set; }

        /// <summary>
        /// Gets or sets the default pallet view
        /// </summary>
        public string DefaultPalletView { get; set; }

        /// <summary>
        /// Gets or sets the default pallet list printer
        /// </summary>
        public string DefaultPalletListPrinter { get; set; }

        /// <summary>
        /// Gets or sets the default item label printer
        /// </summary>
        public string DefaultItemLabelPrinter { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to show confirmation prompts
        /// </summary>
        public bool ShowConfirmationPrompts { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to auto-print pallet lists when closing
        /// </summary>
        public bool AutoPrintPalletList { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to use special printer for special clients
        /// </summary>
        public bool UseSpecialPrinterForSpecialClients { get; set; }

        /// <summary>
        /// Gets or sets the session timeout in minutes
        /// </summary>
        public int SessionTimeoutMinutes { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to remember division and platform
        /// </summary>
        public bool RememberDivisionAndPlatform { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to auto-refresh the pallet list
        /// </summary>
        public bool AutoRefreshPalletList { get; set; }

        /// <summary>
        /// Gets or sets the auto-refresh interval in seconds
        /// </summary>
        public int AutoRefreshIntervalSeconds { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to show browser notifications
        /// </summary>
        public bool ShowBrowserNotifications { get; set; }
    }
}

===============================================================================
File: Exceptions\DomainException.cs
===============================================================================
using System;

namespace PalletManagementSystem.Core.Exceptions
{
    /// <summary>
    /// Base exception for all domain-specific exceptions
    /// </summary>
    public class DomainException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DomainException"/> class
        /// </summary>
        public DomainException() : base() { }

        /// <summary>
        /// Initializes a new instance of the <see cref="DomainException"/> class with a message
        /// </summary>
        /// <param name="message">The error message</param>
        public DomainException(string message) : base(message) { }

        /// <summary>
        /// Initializes a new instance of the <see cref="DomainException"/> class with a message and inner exception
        /// </summary>
        /// <param name="message">The error message</param>
        /// <param name="innerException">The inner exception</param>
        public DomainException(string message, Exception innerException) : base(message, innerException) { }
    }

    /// <summary>
    /// Exception thrown when attempting to modify a closed pallet
    /// </summary>
    public class PalletClosedException : DomainException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PalletClosedException"/> class
        /// </summary>
        public PalletClosedException() : base("Operation cannot be performed on a closed pallet") { }

        /// <summary>
        /// Initializes a new instance of the <see cref="PalletClosedException"/> class with a message
        /// </summary>
        /// <param name="message">The error message</param>
        public PalletClosedException(string message) : base(message) { }

        /// <summary>
        /// Initializes a new instance of the <see cref="PalletClosedException"/> class with a message and inner exception
        /// </summary>
        /// <param name="message">The error message</param>
        /// <param name="innerException">The inner exception</param>
        public PalletClosedException(string message, Exception innerException) : base(message, innerException) { }
    }

    /// <summary>
    /// Exception thrown when item validation fails
    /// </summary>
    public class ItemValidationException : DomainException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ItemValidationException"/> class
        /// </summary>
        public ItemValidationException() : base("Item validation failed") { }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemValidationException"/> class with a message
        /// </summary>
        /// <param name="message">The error message</param>
        public ItemValidationException(string message) : base(message) { }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemValidationException"/> class with a message and inner exception
        /// </summary>
        /// <param name="message">The error message</param>
        /// <param name="innerException">The inner exception</param>
        public ItemValidationException(string message, Exception innerException) : base(message, innerException) { }
    }

    /// <summary>
    /// Exception thrown when pallet validation fails
    /// </summary>
    public class PalletValidationException : DomainException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PalletValidationException"/> class
        /// </summary>
        public PalletValidationException() : base("Pallet validation failed") { }

        /// <summary>
        /// Initializes a new instance of the <see cref="PalletValidationException"/> class with a message
        /// </summary>
        /// <param name="message">The error message</param>
        public PalletValidationException(string message) : base(message) { }

        /// <summary>
        /// Initializes a new instance of the <see cref="PalletValidationException"/> class with a message and inner exception
        /// </summary>
        /// <param name="message">The error message</param>
        /// <param name="innerException">The inner exception</param>
        public PalletValidationException(string message, Exception innerException) : base(message, innerException) { }
    }

    /// <summary>
    /// Exception thrown when an entity is not found
    /// </summary>
    public class EntityNotFoundException : DomainException
    {
        /// <summary>
        /// Gets the ID of the entity that was not found
        /// </summary>
        public object EntityId { get; }

        /// <summary>
        /// Gets the type of the entity that was not found
        /// </summary>
        public string EntityType { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="EntityNotFoundException"/> class
        /// </summary>
        /// <param name="entityType">The type of entity</param>
        /// <param name="entityId">The ID of the entity</param>
        public EntityNotFoundException(string entityType, object entityId)
            : base($"{entityType} with ID {entityId} was not found")
        {
            EntityType = entityType;
            EntityId = entityId;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EntityNotFoundException"/> class with a message
        /// </summary>
        /// <param name="message">The error message</param>
        /// <param name="entityType">The type of entity</param>
        /// <param name="entityId">The ID of the entity</param>
        public EntityNotFoundException(string message, string entityType, object entityId)
            : base(message)
        {
            EntityType = entityType;
            EntityId = entityId;
        }
    }
}

===============================================================================
File: Extensions\QueryableExtensions.cs
===============================================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using Microsoft.EntityFrameworkCore;

namespace PalletManagementSystem.Core.Extensions
{
    /// <summary>
    /// Extension methods for IQueryable to standardize navigation property loading
    /// </summary>
    public static class QueryableExtensions
    {
        /// <summary>
        /// Applies a collection of string-based include paths to the query
        /// </summary>
        /// <typeparam name="T">The entity type</typeparam>
        /// <param name="query">The query to extend</param>
        /// <param name="includes">The collection of include paths</param>
        /// <returns>The query with includes applied</returns>
        public static IQueryable<T> IncludeMultiple<T>(this IQueryable<T> query, IEnumerable<string> includes)
            where T : class
        {
            if (includes == null)
                return query;

            foreach (var include in includes)
            {
                if (!string.IsNullOrWhiteSpace(include))
                {
                    query = query.Include(include);
                }
            }

            return query;
        }

        /// <summary>
        /// Applies a collection of expression-based includes to the query
        /// </summary>
        /// <typeparam name="T">The entity type</typeparam>
        /// <param name="query">The query to extend</param>
        /// <param name="includes">The collection of include expressions</param>
        /// <returns>The query with includes applied</returns>
        public static IQueryable<T> IncludeMultiple<T>(this IQueryable<T> query, IEnumerable<Expression<Func<T, object>>> includes)
            where T : class
        {
            if (includes == null)
                return query;

            foreach (var include in includes)
            {
                query = query.Include(include);
            }

            return query;
        }
    }
}

===============================================================================
File: Extensions\QueryExtensions.cs
===============================================================================
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using PalletManagementSystem.Core.Interfaces.Repositories;

namespace PalletManagementSystem.Core.Extensions
{
    /// <summary>
    /// Extension methods for IQuery to simplify usage
    /// </summary>
    public static class QueryExtensions
    {
        /// <summary>
        /// Includes multiple related entities in the query
        /// </summary>
        /// <typeparam name="T">The entity type</typeparam>
        /// <param name="query">The query</param>
        /// <param name="includes">The include paths</param>
        /// <returns>The query with includes applied</returns>
        public static IQuery<T> IncludeMultiple<T>(this IQuery<T> query, IEnumerable<string> includes) where T : class
        {
            if (includes == null)
                return query;

            IQuery<T> result = query;
            foreach (var include in includes)
            {
                if (!string.IsNullOrWhiteSpace(include))
                {
                    result = result.Include(include);
                }
            }

            return result;
        }

        /// <summary>
        /// Includes multiple related entities in the query using expressions
        /// </summary>
        /// <typeparam name="T">The entity type</typeparam>
        /// <param name="query">The query</param>
        /// <param name="includes">The include expressions</param>
        /// <returns>The query with includes applied</returns>
        public static IQuery<T> IncludeMultiple<T>(this IQuery<T> query, IEnumerable<Expression<Func<T, object>>> includes) where T : class
        {
            if (includes == null)
                return query;

            IQuery<T> result = query;
            foreach (var include in includes)
            {
                result = result.Include(include);
            }

            return result;
        }
    }
}

===============================================================================
File: Extensions\RepositoryExtensions.cs
===============================================================================
using System.Linq;
using PalletManagementSystem.Core.Interfaces.Repositories;

namespace PalletManagementSystem.Core.Extensions
{
    /// <summary>
    /// Extension methods for repositories
    /// </summary>
    public static class RepositoryExtensions
    {
        /// <summary>
        /// Creates a query from the repository
        /// </summary>
        /// <typeparam name="T">The entity type</typeparam>
        /// <param name="repository">The repository</param>
        /// <returns>A query for the entities</returns>
        public static IQuery<T> AsQuery<T>(this IRepository<T> repository) where T : class
        {
            return repository.GetQuery();
        }

        /// <summary>
        /// Creates a queryable view of the repository (for backward compatibility)
        /// </summary>
        /// <typeparam name="T">The entity type</typeparam>
        /// <param name="repository">The repository</param>
        /// <returns>A queryable of the entities</returns>
        public static IQueryable<T> AsQueryable<T>(this IRepository<T> repository) where T : class
        {
            return repository.GetQueryable();
        }
    }
}

===============================================================================
File: Extensions\RepositoryIncludeExtensions.cs
===============================================================================
using System;
using System.Linq;
using System.Linq.Expressions;
using Microsoft.EntityFrameworkCore;
using PalletManagementSystem.Core.Models;

namespace PalletManagementSystem.Core.Extensions
{
    /// <summary>
    /// Extension methods for standardized entity include patterns
    /// </summary>
    public static class RepositoryIncludeExtensions
    {
        /// <summary>
        /// Includes the Items collection on a Pallet query
        /// </summary>
        /// <param name="query">The query to extend</param>
        /// <returns>The query with Items included</returns>
        public static IQueryable<Pallet> IncludeItems(this IQueryable<Pallet> query)
        {
            return query.Include(p => p.Items);
        }

        /// <summary>
        /// Includes the Pallet navigation property on an Item query
        /// </summary>
        /// <param name="query">The query to extend</param>
        /// <returns>The query with Pallet included</returns>
        public static IQueryable<Item> IncludePallet(this IQueryable<Item> query)
        {
            return query.Include(i => i.Pallet);
        }

        /// <summary>
        /// Includes the Pallet navigation property and the Pallet's Items collection on an Item query
        /// </summary>
        /// <param name="query">The query to extend</param>
        /// <returns>The query with Pallet and Pallet's Items included</returns>
        public static IQueryable<Item> IncludePalletWithItems(this IQueryable<Item> query)
        {
            return query.Include(i => i.Pallet)
                        .ThenInclude(p => p.Items);
        }
    }
}

===============================================================================
File: Interfaces\IUserSessionContext.cs
===============================================================================
// src/PalletManagementSystem.Core/Interfaces/IUserSessionContext.cs
using PalletManagementSystem.Core.Models.Enums;

namespace PalletManagementSystem.Core.Interfaces
{
    /// <summary>
    /// Defines an interface for accessing user-specific session context,
    /// such as selected Division and Platform.
    /// This abstracts the underlying storage mechanism (e.g., web session).
    /// </summary>
    public interface IUserSessionContext
    {
        /// <summary>
        /// Gets the currently selected Division for the user's session.
        /// </summary>
        /// <returns>The current Division.</returns>
        Division GetCurrentDivision();

        /// <summary>
        /// Gets the currently selected Platform for the user's session.
        /// </summary>
        /// <returns>The current Platform.</returns>
        Platform GetCurrentPlatform();

        // Add other session-related methods here if needed in the future
        // For example: bool IsTouchModeEnabled();
    }
}

===============================================================================
File: Interfaces\Repositories\IItemRepository.cs
===============================================================================
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using PalletManagementSystem.Core.DTOs;
using PalletManagementSystem.Core.Models;

namespace PalletManagementSystem.Core.Interfaces.Repositories
{
    /// <summary>
    /// Repository interface for item entities
    /// </summary>
    public interface IItemRepository : IRepository<Item>
    {

        /// <summary>
        /// Gets an item by ID with its pallet (for domain operations)
        /// </summary>
        /// <param name="id">The item ID</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The item with pallet, or null if not found</returns>
        Task<Item> GetByIdWithPalletAsync(int id, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets an item by ID as a list DTO (without pallet)
        /// </summary>
        /// <param name="id">The item ID</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The item list DTO, or null if not found</returns>
        Task<ItemListDto> GetItemListByIdAsync(int id, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets an item by ID as a detail DTO (with pallet)
        /// </summary>
        /// <param name="id">The item ID</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The item detail DTO, or null if not found</returns>
        Task<ItemDetailDto> GetItemDetailByIdAsync(int id, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets an item by its item number as a list DTO (without pallet)
        /// </summary>
        /// <param name="itemNumber">The item number</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The item list DTO, or null if not found</returns>
        Task<ItemListDto> GetItemListByNumberAsync(string itemNumber, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets an item by its item number as a detail DTO (with pallet)
        /// </summary>
        /// <param name="itemNumber">The item number</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The item detail DTO, or null if not found</returns>
        Task<ItemDetailDto> GetItemDetailByNumberAsync(string itemNumber, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets items by pallet ID as list DTOs
        /// </summary>
        /// <param name="palletId">The pallet ID</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A read-only list of matching item list DTOs</returns>
        Task<IReadOnlyList<ItemListDto>> GetItemsByPalletIdAsync(int palletId, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets items by client code as list DTOs
        /// </summary>
        /// <param name="clientCode">The client code</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A read-only list of matching item list DTOs</returns>
        Task<IReadOnlyList<ItemListDto>> GetItemsByClientCodeAsync(string clientCode, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets items by manufacturing order as list DTOs
        /// </summary>
        /// <param name="manufacturingOrder">The manufacturing order</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A read-only list of matching item list DTOs</returns>
        Task<IReadOnlyList<ItemListDto>> GetItemsByManufacturingOrderAsync(string manufacturingOrder, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the next item number
        /// </summary>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The next item number</returns>
        Task<string> GetNextItemNumberAsync(CancellationToken cancellationToken = default);

        /// <summary>
        /// Searches for items matching the keyword as list DTOs
        /// </summary>
        /// <param name="keyword">The search keyword</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A read-only list of matching item list DTOs</returns>
        Task<IReadOnlyList<ItemListDto>> SearchItemsAsync(string keyword, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a paged list of items as list DTOs
        /// </summary>
        /// <param name="pageNumber">The page number (1-based)</param>
        /// <param name="pageSize">The page size</param>
        /// <param name="palletId">Optional pallet ID filter</param>
        /// <param name="clientCode">Optional client code filter</param>
        /// <param name="manufacturingOrder">Optional manufacturing order filter</param>
        /// <param name="keyword">Optional search keyword</param>
        /// <param name="orderByCreatedDate">Order by created date if true, otherwise by item number</param>
        /// <param name="descending">Whether to order in descending order</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A paged result of item list DTOs</returns>
        Task<PagedResultDto<ItemListDto>> GetPagedItemsAsync(
            int pageNumber,
            int pageSize,
            int? palletId = null,
            string clientCode = null,
            string manufacturingOrder = null,
            string keyword = null,
            bool orderByCreatedDate = true,
            bool descending = true,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a paged list of items as detail DTOs (with pallets)
        /// </summary>
        /// <param name="pageNumber">The page number (1-based)</param>
        /// <param name="pageSize">The page size</param>
        /// <param name="palletId">Optional pallet ID filter</param>
        /// <param name="clientCode">Optional client code filter</param>
        /// <param name="manufacturingOrder">Optional manufacturing order filter</param>
        /// <param name="keyword">Optional search keyword</param>
        /// <param name="orderByCreatedDate">Order by created date if true, otherwise by item number</param>
        /// <param name="descending">Whether to order in descending order</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A paged result of item detail DTOs</returns>
        Task<PagedResultDto<ItemDetailDto>> GetPagedItemDetailsAsync(
            int pageNumber,
            int pageSize,
            int? palletId = null,
            string clientCode = null,
            string manufacturingOrder = null,
            string keyword = null,
            bool orderByCreatedDate = true,
            bool descending = true,
            CancellationToken cancellationToken = default);
    }
}

===============================================================================
File: Interfaces\Repositories\IPalletRepository.cs
===============================================================================
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using PalletManagementSystem.Core.DTOs;
using PalletManagementSystem.Core.Models;
using PalletManagementSystem.Core.Models.Enums;

namespace PalletManagementSystem.Core.Interfaces.Repositories
{
    /// <summary>
    /// Repository interface for pallet entities
    /// </summary>
    public interface IPalletRepository : IRepository<Pallet>
    {
        /// <summary>
        /// Gets a pallet by ID with its items
        /// </summary>
        /// <param name="id">The pallet ID</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The pallet with items, or null if not found</returns>
        Task<Pallet> GetByIdWithItemsAsync(int id, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a pallet by ID as a list DTO (without items)
        /// </summary>
        /// <param name="id">The pallet ID</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The pallet list DTO, or null if not found</returns>
        Task<PalletListDto> GetPalletListByIdAsync(int id, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a pallet by ID as a detail DTO (with items)
        /// </summary>
        /// <param name="id">The pallet ID</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The pallet detail DTO, or null if not found</returns>
        Task<PalletDetailDto> GetPalletDetailByIdAsync(int id, CancellationToken cancellationToken = default); 

       

        /// <summary>
        /// Gets a pallet by its pallet number as a list DTO (without items)
        /// </summary>
        /// <param name="palletNumber">The pallet number</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The pallet list DTO, or null if not found</returns>
        Task<PalletListDto> GetPalletListByNumberAsync(string palletNumber, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a pallet by its pallet number as a detail DTO (with items)
        /// </summary>
        /// <param name="palletNumber">The pallet number</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The pallet detail DTO, or null if not found</returns>
        Task<PalletDetailDto> GetPalletDetailByNumberAsync(string palletNumber, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets pallets by division and platform as list DTOs
        /// </summary>
        /// <param name="division">The division</param>
        /// <param name="platform">The platform</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A read-only list of matching pallet list DTOs</returns>
        Task<IReadOnlyList<PalletListDto>> GetPalletsByDivisionAndPlatformAsync(
            Division division,
            Platform platform,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets pallets by division and platform as detail DTOs (with items)
        /// </summary>
        /// <param name="division">The division</param>
        /// <param name="platform">The platform</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A read-only list of matching pallet detail DTOs</returns>
        Task<IReadOnlyList<PalletDetailDto>> GetPalletDetailsByDivisionAndPlatformAsync(
            Division division,
            Platform platform,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets pallets by status as list DTOs
        /// </summary>
        /// <param name="isClosed">A value indicating whether to get closed pallets</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A read-only list of matching pallet list DTOs</returns>
        Task<IReadOnlyList<PalletListDto>> GetPalletsByStatusAsync(
            bool isClosed,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets pallets by manufacturing order as list DTOs
        /// </summary>
        /// <param name="manufacturingOrder">The manufacturing order</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A read-only list of matching pallet list DTOs</returns>
        Task<IReadOnlyList<PalletListDto>> GetPalletsByManufacturingOrderAsync(
            string manufacturingOrder,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the next temporary sequence number
        /// </summary>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The next temporary sequence number</returns>
        Task<int> GetNextTemporarySequenceNumberAsync(CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the next permanent sequence number for a division
        /// </summary>
        /// <param name="division">The division</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The next permanent sequence number</returns>
        Task<int> GetNextPermanentSequenceNumberAsync(Division division, CancellationToken cancellationToken = default);

        /// <summary>
        /// Searches for pallets matching the keyword as list DTOs
        /// </summary>
        /// <param name="keyword">The search keyword</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A read-only list of matching pallet list DTOs</returns>
        Task<IReadOnlyList<PalletListDto>> SearchPalletsAsync(string keyword, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a paged list of pallets as list DTOs
        /// </summary>
        /// <param name="pageNumber">The page number (1-based)</param>
        /// <param name="pageSize">The page size</param>
        /// <param name="division">Optional division filter</param>
        /// <param name="platform">Optional platform filter</param>
        /// <param name="isClosed">Optional status filter</param>
        /// <param name="keyword">Optional search keyword</param>
        /// <param name="orderByCreatedDate">Order by created date if true, otherwise by pallet number</param>
        /// <param name="descending">Whether to order in descending order</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A paged result of pallet list DTOs</returns>
        Task<PagedResultDto<PalletListDto>> GetPagedPalletsAsync(
            int pageNumber,
            int pageSize,
            Division? division = null,
            Platform? platform = null,
            bool? isClosed = null,
            string keyword = null,
            bool orderByCreatedDate = false,
            bool descending = false,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets search results DTOs for pallets matching the keyword in pallet number or manufacturing order
        /// </summary>
        /// <param name="keyword">The search keyword</param>
        /// <param name="maxResults">Maximum number of results to return (0 for unlimited)</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A collection of search result DTOs</returns>
        Task<IEnumerable<SearchResultDto>> GetPalletSearchResultsAsync(
            string keyword,
            int maxResults = 0,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets search suggestion DTOs for pallets matching the keyword in pallet number or manufacturing order
        /// </summary>
        /// <param name="keyword">The search keyword</param>
        /// <param name="maxResults">Maximum number of suggestions to return</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A collection of search suggestion DTOs</returns>
        Task<IEnumerable<SearchSuggestionDto>> GetPalletSearchSuggestionsAsync(
            string keyword,
            int maxResults = 0,
            CancellationToken cancellationToken = default);
    }


}

===============================================================================
File: Interfaces\Repositories\IQuery.cs
===============================================================================
using System;
using System.Linq.Expressions;

namespace PalletManagementSystem.Core.Interfaces.Repositories
{
    /// <summary>
    /// Persistence-ignorant queryable interface to remove direct dependency on EF Core's IQueryable
    /// </summary>
    /// <typeparam name="T">The entity type</typeparam>
    public interface IQuery<T> where T : class
    {
        /// <summary>
        /// Applies a filter to the query
        /// </summary>
        IQuery<T> Where(Expression<Func<T, bool>> predicate);

        /// <summary>
        /// Includes a related entity
        /// </summary>
        IQuery<T> Include(Expression<Func<T, object>> path);

        /// <summary>
        /// Includes a related entity using a string path
        /// </summary>
        IQuery<T> Include(string path);

        /// <summary>
        /// Executes the query and returns results
        /// </summary>
        System.Collections.Generic.IReadOnlyList<T> ToList();

        /// <summary>
        /// Executes the query and returns the first result
        /// </summary>
        T FirstOrDefault();
    }
}

===============================================================================
File: Interfaces\Repositories\IQueryableRepository.cs
===============================================================================
using System.Linq;

namespace PalletManagementSystem.Core.Interfaces.Repositories
{
    /// <summary>
    /// Interface for repositories that support direct queryable access
    /// </summary>
    /// <typeparam name="T">The entity type</typeparam>
    public interface IQueryableRepository<T> : IRepository<T> where T : class
    {
        /// <summary>
        /// Gets a queryable view of the repository
        /// </summary>
        new IQueryable<T> GetQueryable();
    }
}

===============================================================================
File: Interfaces\Repositories\IRepository.cs
===============================================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Threading.Tasks;
using PalletManagementSystem.Core.Models;

namespace PalletManagementSystem.Core.Interfaces.Repositories
{
    /// <summary>
    /// Generic repository interface with enhanced querying capabilities
    /// </summary>
    /// <typeparam name="T">The entity type</typeparam>
    public interface IRepository<T> where T : class
    {
        /// <summary>
        /// Gets an entity by its identifier
        /// </summary>
        /// <param name="id">The entity identifier</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The entity, or null if not found</returns>
        Task<T> GetByIdAsync(int id, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets all entities
        /// </summary>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A read-only list of all entities</returns>
        Task<IReadOnlyList<T>> GetAllAsync(CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a paged list of all entities
        /// </summary>
        /// <param name="pageNumber">The page number (1-based)</param>
        /// <param name="pageSize">The page size</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A paged result of entities</returns>
        Task<PagedResult<T>> GetPagedAsync(int pageNumber, int pageSize, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets entities matching the specified predicate
        /// </summary>
        /// <param name="predicate">The filter predicate</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A read-only list of matching entities</returns>
        Task<IReadOnlyList<T>> FindAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a paged list of entities matching the specified predicate
        /// </summary>
        /// <param name="predicate">The filter predicate</param>
        /// <param name="pageNumber">The page number (1-based)</param>
        /// <param name="pageSize">The page size</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A paged result of matching entities</returns>
        Task<PagedResult<T>> FindPagedAsync(Expression<Func<T, bool>> predicate, int pageNumber, int pageSize, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets entities matching the specified specification
        /// </summary>
        /// <param name="specification">The specification</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A read-only list of matching entities</returns>
        Task<IReadOnlyList<T>> FindAsync(ISpecification<T> specification, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a single entity matching the specified predicate
        /// </summary>
        /// <param name="predicate">The filter predicate</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The matching entity, or null if not found</returns>
        Task<T> FindFirstAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a single entity matching the specified specification
        /// </summary>
        /// <param name="specification">The specification</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The matching entity, or null if not found</returns>
        Task<T> FindFirstAsync(ISpecification<T> specification, CancellationToken cancellationToken = default);

        /// <summary>
        /// Adds a new entity
        /// </summary>
        /// <param name="entity">The entity to add</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The added entity</returns>
        Task<T> AddAsync(T entity, CancellationToken cancellationToken = default);

        /// <summary>
        /// Adds a range of new entities
        /// </summary>
        /// <param name="entities">The entities to add</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A task representing the asynchronous operation</returns>
        Task AddRangeAsync(IEnumerable<T> entities, CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates an existing entity
        /// </summary>
        /// <param name="entity">The entity to update</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A task representing the asynchronous operation</returns>
        Task UpdateAsync(T entity, CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates a range of existing entities
        /// </summary>
        /// <param name="entities">The entities to update</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A task representing the asynchronous operation</returns>
        Task UpdateRangeAsync(IEnumerable<T> entities, CancellationToken cancellationToken = default);

        /// <summary>
        /// Deletes an entity
        /// </summary>
        /// <param name="entity">The entity to delete</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A task representing the asynchronous operation</returns>
        Task DeleteAsync(T entity, CancellationToken cancellationToken = default);

        /// <summary>
        /// Deletes a range of entities
        /// </summary>
        /// <param name="entities">The entities to delete</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A task representing the asynchronous operation</returns>
        Task DeleteRangeAsync(IEnumerable<T> entities, CancellationToken cancellationToken = default);

        /// <summary>
        /// Checks if any entity matches the specified predicate
        /// </summary>
        /// <param name="predicate">The filter predicate</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>True if any matching entity exists, false otherwise</returns>
        Task<bool> ExistsAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the count of all entities
        /// </summary>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The count of all entities</returns>
        Task<int> CountAsync(CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the count of entities matching the specified predicate
        /// </summary>
        /// <param name="predicate">The filter predicate</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The count of matching entities</returns>
        Task<int> CountAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a queryable for the entity
        /// </summary>
        /// <returns>A queryable for the entity type</returns>
        IQuery<T> GetQuery();

        // Keep the previous method for backward compatibility
        IQueryable<T> GetQueryable();

        /// <summary>
        /// Gets an entity by ID with specified navigation properties
        /// </summary>
        /// <param name="id">The entity ID</param>
        /// <param name="includes">The navigation properties to include</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The entity with included navigation properties</returns>
        Task<T> GetByIdWithIncludesAsync(int id, IEnumerable<string> includes, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets an entity by ID with specified navigation properties
        /// </summary>
        /// <param name="id">The entity ID</param>
        /// <param name="includes">The navigation properties to include as expressions</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The entity with included navigation properties</returns>
        Task<T> GetByIdWithIncludesAsync(int id, IEnumerable<Expression<Func<T, object>>> includes, CancellationToken cancellationToken = default);

        /// <summary>
        /// Finds entities matching a predicate with specified navigation properties
        /// </summary>
        /// <param name="predicate">The filter predicate</param>
        /// <param name="includes">The navigation properties to include</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A read-only list of matching entities with includes</returns>
        Task<IReadOnlyList<T>> FindWithIncludesAsync(
            Expression<Func<T, bool>> predicate,
            IEnumerable<string> includes,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Finds entities matching a predicate with specified navigation properties
        /// </summary>
        /// <param name="predicate">The filter predicate</param>
        /// <param name="includes">The navigation properties to include as expressions</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A read-only list of matching entities with includes</returns>
        Task<IReadOnlyList<T>> FindWithIncludesAsync(
            Expression<Func<T, bool>> predicate,
            IEnumerable<Expression<Func<T, object>>> includes,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Finds the first entity matching a predicate with specified navigation properties
        /// </summary>
        /// <param name="predicate">The filter predicate</param>
        /// <param name="includes">The navigation properties to include</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The first matching entity with included navigation properties, or null if not found</returns>
        Task<T> FindFirstWithIncludesAsync(
            Expression<Func<T, bool>> predicate,
            IEnumerable<string> includes,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Finds the first entity matching a predicate with specified navigation properties
        /// </summary>
        /// <param name="predicate">The filter predicate</param>
        /// <param name="includes">The navigation properties to include as expressions</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The first matching entity with included navigation properties, or null if not found</returns>
        Task<T> FindFirstWithIncludesAsync(
            Expression<Func<T, bool>> predicate,
            IEnumerable<Expression<Func<T, object>>> includes,
            CancellationToken cancellationToken = default);
    }
}

===============================================================================
File: Interfaces\Repositories\ISpecification.cs
===============================================================================
using System;
using System.Collections.Generic;
using System.Linq.Expressions;

namespace PalletManagementSystem.Core.Interfaces.Repositories
{
    /// <summary>
    /// Enhanced specification pattern for creating reusable, composable queries
    /// </summary>
    /// <typeparam name="T">The entity type</typeparam>
    public interface ISpecification<T>
    {
        /// <summary>
        /// Gets the criteria expression to filter entities
        /// </summary>
        Expression<Func<T, bool>> Criteria { get; }

        /// <summary>
        /// Gets the list of include expressions for eager loading
        /// </summary>
        List<Expression<Func<T, object>>> Includes { get; }

        /// <summary>
        /// Gets the list of string-based include paths for eager loading
        /// </summary>
        List<string> IncludeStrings { get; }

        /// <summary>
        /// Gets the ordering expression for the query
        /// </summary>
        Expression<Func<T, object>> OrderBy { get; }

        /// <summary>
        /// Gets the descending ordering expression for the query
        /// </summary>
        Expression<Func<T, object>> OrderByDescending { get; }

        /// <summary>
        /// Gets a value indicating whether pagination is enabled
        /// </summary>
        bool IsPagingEnabled { get; }

        /// <summary>
        /// Gets the number of entities to skip
        /// </summary>
        int Skip { get; }

        /// <summary>
        /// Gets the number of entities to take
        /// </summary>
        int Take { get; }
    }
}

===============================================================================
File: Interfaces\Repositories\IUnitOfWork.cs
===============================================================================
using System;
using System.Data;
using System.Threading;
using System.Threading.Tasks;

namespace PalletManagementSystem.Core.Interfaces.Repositories
{
    /// <summary>
    /// Represents a unit of work for managing transactions across multiple repositories
    /// </summary>
    public interface IUnitOfWork : IDisposable
    {
        /// <summary>
        /// Gets the repository for the specified entity type
        /// </summary>
        /// <typeparam name="T">The entity type</typeparam>
        /// <returns>The repository</returns>
        IRepository<T> Repository<T>() where T : class;

        /// <summary>
        /// Gets the pallet repository
        /// </summary>
        IPalletRepository PalletRepository { get; }

        /// <summary>
        /// Gets the item repository
        /// </summary>
        IItemRepository ItemRepository { get; }

        /// <summary>
        /// Saves all changes made in this unit of work to the database
        /// </summary>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The number of state entries written to the database</returns>
        Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);

        /// <summary>
        /// Begins a transaction
        /// </summary>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A task representing the asynchronous operation</returns>
        Task BeginTransactionAsync(CancellationToken cancellationToken = default);

        /// <summary>
        /// Begins a transaction with specified isolation level
        /// </summary>
        /// <param name="isolationLevel">The isolation level</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A task representing the asynchronous operation</returns>
        Task BeginTransactionAsync(IsolationLevel isolationLevel, CancellationToken cancellationToken = default);

        /// <summary>
        /// Commits the transaction
        /// </summary>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A task representing the asynchronous operation</returns>
        Task CommitTransactionAsync(CancellationToken cancellationToken = default);

        /// <summary>
        /// Rolls back the transaction
        /// </summary>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A task representing the asynchronous operation</returns>
        Task RollbackTransactionAsync(CancellationToken cancellationToken = default);
    }
}

===============================================================================
File: Interfaces\Services\IItemService.cs
===============================================================================
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using PalletManagementSystem.Core.DTOs;

namespace PalletManagementSystem.Core.Interfaces.Services
{
    /// <summary>
    /// Service interface for item operations
    /// </summary>
    public interface IItemService
    {
        /// <summary>
        /// Gets an item by its ID (without pallet)
        /// </summary>
        /// <param name="id">The item ID</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The item DTO, or null if not found</returns>
        Task<ItemListDto> GetItemByIdAsync(int id, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets an item detail by its ID (with pallet)
        /// </summary>
        /// <param name="id">The item ID</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The item detail DTO, or null if not found</returns>
        Task<ItemDetailDto> GetItemDetailByIdAsync(int id, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets an item by its number (without pallet)
        /// </summary>
        /// <param name="itemNumber">The item number</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The item DTO, or null if not found</returns>
        Task<ItemListDto> GetItemByNumberAsync(string itemNumber, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets items by pallet ID
        /// </summary>
        /// <param name="palletId">The pallet ID</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A collection of item DTOs</returns>
        Task<IEnumerable<ItemListDto>> GetItemsByPalletIdAsync(int palletId, CancellationToken cancellationToken = default);

        /// <summary>
        /// Creates a new item and adds it to a pallet
        /// </summary>
        /// <param name="itemDto">The item data</param>
        /// <param name="palletId">The pallet ID</param>
        /// <param name="username">The username of the creator</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The created item DTO</returns>
        Task<ItemDto> CreateItemAsync(ItemDto itemDto, int palletId, string username, CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates an item's editable properties
        /// </summary>
        /// <param name="itemId">The item ID</param>
        /// <param name="updateDto">The update data</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The updated item detail DTO</returns>
        Task<ItemDetailDto> UpdateItemAsync(
            int itemId, UpdateItemDto updateDto, CancellationToken cancellationToken = default);

        /// <summary>
        /// Moves an item to another pallet
        /// </summary>
        /// <param name="itemId">The item ID</param>
        /// <param name="targetPalletId">The target pallet ID</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The moved item detail DTO</returns>
        Task<ItemDetailDto> MoveItemToPalletAsync(int itemId, int targetPalletId, CancellationToken cancellationToken = default);

        /// <summary>
        /// Checks if an item can be moved to another pallet
        /// </summary>
        /// <param name="itemId">The item ID</param>
        /// <param name="targetPalletId">The target pallet ID</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>True if the item can be moved, false otherwise</returns>
        Task<bool> CanMoveItemToPalletAsync(int itemId, int targetPalletId, CancellationToken cancellationToken = default);

        /// <summary>
        /// Searches for items matching the keyword
        /// </summary>
        /// <param name="keyword">The search keyword</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A collection of matching item DTOs</returns>
        Task<IEnumerable<ItemListDto>> SearchItemsAsync(string keyword, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a paged list of items
        /// </summary>
        /// <param name="pageNumber">The page number (1-based)</param>
        /// <param name="pageSize">The page size</param>
        /// <param name="palletId">Optional pallet ID filter</param>
        /// <param name="clientCode">Optional client code filter</param>
        /// <param name="manufacturingOrder">Optional manufacturing order filter</param>
        /// <param name="keyword">Optional search keyword</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A paged result of item DTOs</returns>
        Task<PagedResultDto<ItemListDto>> GetPagedItemsAsync(
            int pageNumber,
            int pageSize,
            int? palletId = null,
            string clientCode = null,
            string manufacturingOrder = null,
            string keyword = null,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a paged list of item details
        /// </summary>
        /// <param name="pageNumber">The page number (1-based)</param>
        /// <param name="pageSize">The page size</param>
        /// <param name="palletId">Optional pallet ID filter</param>
        /// <param name="clientCode">Optional client code filter</param>
        /// <param name="manufacturingOrder">Optional manufacturing order filter</param>
        /// <param name="keyword">Optional search keyword</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A paged result of item detail DTOs</returns>
        Task<PagedResultDto<ItemDetailDto>> GetPagedItemDetailsAsync(
            int pageNumber,
            int pageSize,
            int? palletId = null,
            string clientCode = null,
            string manufacturingOrder = null,
            string keyword = null,
            CancellationToken cancellationToken = default);
    }
}

===============================================================================
File: Interfaces\Services\IPalletNumberGenerator.cs
===============================================================================
using System.Threading.Tasks;
using PalletManagementSystem.Core.Models.Enums;
using PalletManagementSystem.Core.Models.ValueObjects;

namespace PalletManagementSystem.Core.Interfaces.Services
{
    /// <summary>
    /// Interface for generating and validating pallet numbers
    /// </summary>
    public interface IPalletNumberGenerator
    {
        /// <summary>
        /// Generates a new temporary pallet number
        /// </summary>
        /// <param name="division">The division</param>
        /// <returns>The temporary pallet number</returns>
        Task<PalletNumber> GenerateTemporaryNumberAsync(Division division);

        /// <summary>
        /// Generates a new permanent pallet number
        /// </summary>
        /// <param name="division">The division</param>
        /// <returns>The permanent pallet number</returns>
        Task<PalletNumber> GeneratePermanentNumberAsync(Division division);

        /// <summary>
        /// Checks if a pallet number already exists
        /// </summary>
        /// <param name="palletNumber">The pallet number to check</param>
        /// <returns>True if the pallet number exists, false otherwise</returns>
        Task<bool> PalletNumberExistsAsync(string palletNumber);

        /// <summary>
        /// Validates a pallet number format
        /// </summary>
        /// <param name="palletNumber">The pallet number to validate</param>
        /// <param name="division">The division</param>
        /// <returns>True if the format is valid, false otherwise</returns>
        bool ValidatePalletNumberFormat(string palletNumber, Division division);
    }
}

===============================================================================
File: Interfaces\Services\IPalletService.cs
===============================================================================
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using PalletManagementSystem.Core.DTOs;
using PalletManagementSystem.Core.Models.Enums;

namespace PalletManagementSystem.Core.Interfaces.Services
{
    /// <summary>
    /// Service interface for pallet operations
    /// </summary>
    public interface IPalletService
    {
        /// <summary>
        /// Gets a pallet by its ID (without items)
        /// </summary>
        /// <param name="id">The pallet ID</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The pallet DTO, or null if not found</returns>
        Task<PalletListDto> GetPalletByIdAsync(int id, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a pallet detail by its ID (with items)
        /// </summary>
        /// <param name="id">The pallet ID</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The pallet detail DTO, or null if not found</returns>
        Task<PalletDetailDto> GetPalletDetailByIdAsync(int id, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a pallet by its number (without items)
        /// </summary>
        /// <param name="palletNumber">The pallet number</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The pallet DTO, or null if not found</returns>
        Task<PalletListDto> GetPalletByNumberAsync(string palletNumber, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a pallet detail by its number (with items)
        /// </summary>
        /// <param name="palletNumber">The pallet number</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The pallet detail DTO, or null if not found</returns>
        Task<PalletDetailDto> GetPalletDetailByNumberAsync(string palletNumber, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets pallets by division and platform
        /// </summary>
        /// <param name="division">The division</param>
        /// <param name="platform">The platform</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A collection of pallet DTOs</returns>
        Task<IEnumerable<PalletListDto>> GetPalletsByDivisionAndPlatformAsync(
            Division division, Platform platform, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets pallets by status (open or closed)
        /// </summary>
        /// <param name="isClosed">A value indicating whether to get closed pallets</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A collection of pallet DTOs</returns>
        Task<IEnumerable<PalletListDto>> GetPalletsByStatusAsync(
            bool isClosed, CancellationToken cancellationToken = default);

        /// <summary>
        /// Creates a new pallet
        /// </summary>
        /// <param name="manufacturingOrder">The manufacturing order</param>
        /// <param name="division">The division</param>
        /// <param name="platform">The platform</param>
        /// <param name="unitOfMeasure">The unit of measure</param>
        /// <param name="username">The username of the creator</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The created pallet DTO</returns>
        Task<PalletListDto> CreatePalletAsync(
            string manufacturingOrder,
            Division division,
            Platform platform,
            UnitOfMeasure unitOfMeasure,
            string username,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Closes a pallet
        /// </summary>
        /// <param name="palletId">The pallet ID</param>
        /// <param name="autoPrint">Whether to automatically print the pallet list</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The closed pallet detail DTO</returns>
        Task<PalletDetailDto> ClosePalletAsync(
            int palletId, bool autoPrint = true, CancellationToken cancellationToken = default);

        /// <summary>
        /// Searches for pallets matching the keyword
        /// </summary>
        /// <param name="keyword">The search keyword</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A collection of matching pallet DTOs</returns>
        Task<IEnumerable<PalletListDto>> SearchPalletsAsync(
            string keyword, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a paged list of pallets
        /// </summary>
        /// <param name="pageNumber">The page number (1-based)</param>
        /// <param name="pageSize">The page size</param>
        /// <param name="division">Optional division filter</param>
        /// <param name="platform">Optional platform filter</param>
        /// <param name="isClosed">Optional status filter</param>
        /// <param name="keyword">Optional search keyword</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A paged result of pallet DTOs</returns>
        Task<PagedResultDto<PalletListDto>> GetPagedPalletsAsync(
            int pageNumber,
            int pageSize,
            Division? division = null,
            Platform? platform = null,
            bool? isClosed = null,
            string keyword = null,
            CancellationToken cancellationToken = default);
    }
}

===============================================================================
File: Interfaces\Services\IPlatformValidationService.cs
===============================================================================
using PalletManagementSystem.Core.Models.Enums;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace PalletManagementSystem.Core.Interfaces.Services
{
    /// <summary>
    /// Service for validating and managing platform and division relationships
    /// </summary>
    public interface IPlatformValidationService
    {
        /// <summary>
        /// Determines if a platform is valid for a division
        /// </summary>
        /// <param name="platform">The platform to validate</param>
        /// <param name="division">The division to validate against</param>
        /// <returns>True if the platform is valid for the division, false otherwise</returns>
        Task<bool> IsValidPlatformForDivisionAsync(Platform platform, Division division);

        /// <summary>
        /// Gets the default platform for a division
        /// </summary>
        /// <param name="division">The division</param>
        /// <returns>The default platform for the specified division</returns>
        Task<Platform> GetDefaultPlatformForDivisionAsync(Division division);

        /// <summary>
        /// Gets all platforms available for a division
        /// </summary>
        /// <param name="division">The division</param>
        /// <returns>Collection of platforms valid for the division</returns>
        Task<IEnumerable<Platform>> GetPlatformsForDivisionAsync(Division division);
    }
}

===============================================================================
File: Interfaces\Services\IPrinterService.cs
===============================================================================
using PalletManagementSystem.Core.Models.Enums;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace PalletManagementSystem.Core.Interfaces.Services
{
    /// <summary>
    /// Service for printing pallet lists and item labels
    /// </summary>
    public interface IPrinterService
    {
        /// <summary>
        /// Prints a pallet list
        /// </summary>
        /// <param name="palletId">The pallet ID</param>
        /// <returns>Task representing the async operation</returns>
        Task<bool> PrintPalletListAsync(int palletId);

        /// <summary>
        /// Prints an item label
        /// </summary>
        /// <param name="itemId">The item ID</param>
        /// <returns>Task representing the async operation</returns>
        Task<bool> PrintItemLabelAsync(int itemId);

        /// <summary>
        /// Gets the appropriate printer for a pallet list based on division, platform, and special client status
        /// </summary>
        /// <param name="division">The division</param>
        /// <param name="platform">The platform</param>
        /// <param name="hasSpecialClient">Whether the pallet contains items for special clients</param>
        /// <returns>The printer name</returns>
        Task<string> GetPalletListPrinterAsync(Division division, Platform platform, bool hasSpecialClient);

        /// <summary>
        /// Gets the appropriate printer for an item label based on division, platform, and special client status
        /// </summary>
        /// <param name="division">The division</param>
        /// <param name="platform">The platform</param>
        /// <param name="isSpecialClient">Whether the item belongs to a special client</param>
        /// <returns>The printer name</returns>
        Task<string> GetItemLabelPrinterAsync(Division division, Platform platform, bool isSpecialClient);

        /// <summary>
        /// Sets the default pallet list printer for a user
        /// </summary>
        /// <param name="username">The username</param>
        /// <param name="printerName">The printer name</param>
        /// <returns>Task representing the async operation</returns>
        Task<bool> SetDefaultPalletListPrinterAsync(string username, string printerName);

        /// <summary>
        /// Sets the default item label printer for a user
        /// </summary>
        /// <param name="username">The username</param>
        /// <param name="printerName">The printer name</param>
        /// <returns>Task representing the async operation</returns>
        Task<bool> SetDefaultItemLabelPrinterAsync(string username, string printerName);

        /// <summary>
        /// Gets the default pallet list printer for a user
        /// </summary>
        /// <param name="username">The username</param>
        /// <returns>The printer name</returns>
        Task<string> GetDefaultPalletListPrinterAsync(string username);

        /// <summary>
        /// Gets the default item label printer for a user
        /// </summary>
        /// <param name="username">The username</param>
        /// <returns>The printer name</returns>
        Task<string> GetDefaultItemLabelPrinterAsync(string username);

        /// <summary>
        /// Gets available printers for a specific context
        /// </summary>
        /// <param name="printerType">The type of printer (pallet list or item label)</param>
        /// <returns>Collection of available printer names</returns>
        Task<IEnumerable<string>> GetAvailablePrintersAsync(PrinterType printerType);
    }

    /// <summary>
    /// Enum defining printer types
    /// </summary>
    public enum PrinterType
    {
        /// <summary>
        /// Printer for pallet lists
        /// </summary>
        PalletList,

        /// <summary>
        /// Printer for item labels
        /// </summary>
        ItemLabel
    }
}

===============================================================================
File: Interfaces\Services\ISearchService.cs
===============================================================================
using PalletManagementSystem.Core.DTOs;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace PalletManagementSystem.Core.Interfaces.Services
{
    /// <summary>
    /// Service for searching entities in the system
    /// </summary>
    public interface ISearchService
    {
        /// <summary>
        /// Performs a general search across all entities
        /// </summary>
        /// <param name="keyword">The search keyword</param>
        /// <param name="maxResults">Maximum number of results to return (0 for unlimited)</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>Collection of search results</returns>
        Task<IEnumerable<SearchResultDto>> SearchAsync(string keyword, int maxResults = 0, CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets search suggestions as the user types
        /// </summary>
        /// <param name="partialKeyword">The partial search keyword</param>
        /// <param name="maxResults">Maximum number of suggestions to return</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>Collection of search suggestions</returns>
        Task<IEnumerable<SearchSuggestionDto>> GetSearchSuggestionsAsync(string partialKeyword, int maxResults = 5, CancellationToken cancellationToken = default);

        /// <summary>
        /// Searches for pallets matching the keyword
        /// </summary>
        /// <param name="keyword">The search keyword</param>
        /// <param name="maxResults">Maximum number of results to return (0 for unlimited)</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>Collection of pallets matching the search</returns>
        Task<IEnumerable<PalletDto>> SearchPalletsAsync(string keyword, int maxResults = 0, CancellationToken cancellationToken = default);

        /// <summary>
        /// Searches for items matching the keyword
        /// </summary>
        /// <param name="keyword">The search keyword</param>
        /// <param name="maxResults">Maximum number of results to return (0 for unlimited)</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>Collection of items matching the search</returns>
        Task<IEnumerable<ItemDto>> SearchItemsAsync(string keyword, int maxResults = 0, CancellationToken cancellationToken = default);

        /// <summary>
        /// Searches for manufacturing orders matching the keyword
        /// </summary>
        /// <param name="keyword">The search keyword</param>
        /// <param name="maxResults">Maximum number of results to return (0 for unlimited)</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>Collection of manufacturing orders matching the search</returns>
        Task<IEnumerable<string>> SearchManufacturingOrdersAsync(string keyword, int maxResults = 0, CancellationToken cancellationToken = default);

        /// <summary>
        /// Searches for clients matching the keyword
        /// </summary>
        /// <param name="keyword">The search keyword</param>
        /// <param name="maxResults">Maximum number of results to return (0 for unlimited)</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>Collection of clients matching the search</returns>
        Task<IEnumerable<ClientDto>> SearchClientsAsync(string keyword, int maxResults = 0, CancellationToken cancellationToken = default);

        /// <summary>
        /// Validates a search keyword
        /// </summary>
        /// <param name="keyword">The search keyword</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>True if the keyword is valid, false otherwise</returns>
        Task<bool> ValidateSearchKeywordAsync(string keyword, CancellationToken cancellationToken = default);
    }
}

===============================================================================
File: Interfaces\Services\ITransactionManager.cs
===============================================================================
using System;
using System.Data;
using System.Threading;
using System.Threading.Tasks;

namespace PalletManagementSystem.Core.Interfaces.Services
{
    /// <summary>
    /// Interface for managing database transactions
    /// </summary>
    public interface ITransactionManager
    {
        /// <summary>
        /// Executes an action within a transaction
        /// </summary>
        /// <typeparam name="TResult">The result type</typeparam>
        /// <param name="action">The action to execute</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>The result of the action</returns>
        Task<TResult> ExecuteInTransactionAsync<TResult>(
            Func<CancellationToken, Task<TResult>> action,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Executes an action within a transaction
        /// </summary>
        /// <param name="action">The action to execute</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <returns>A task representing the operation</returns>
        Task ExecuteInTransactionAsync(
            Func<CancellationToken, Task> action,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Executes an action within a transaction with specified isolation level
        /// </summary>
        /// <typeparam name="TResult">The result type</typeparam>
        /// <param name="action">The action to execute</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <param name="isolationLevel">The transaction isolation level</param>
        /// <returns>The result of the action</returns>
        Task<TResult> ExecuteInTransactionWithIsolationAsync<TResult>(
            Func<CancellationToken, Task<TResult>> action,
            CancellationToken cancellationToken = default,
            IsolationLevel isolationLevel = IsolationLevel.ReadCommitted);

        /// <summary>
        /// Executes an action within a transaction with specified isolation level
        /// </summary>
        /// <param name="action">The action to execute</param>
        /// <param name="cancellationToken">A token to cancel the operation</param>
        /// <param name="isolationLevel">The transaction isolation level</param>
        /// <returns>A task representing the operation</returns>
        Task ExecuteInTransactionWithIsolationAsync(
            Func<CancellationToken, Task> action,
            CancellationToken cancellationToken = default,
            IsolationLevel isolationLevel = IsolationLevel.ReadCommitted);
    }
}

===============================================================================
File: Interfaces\Services\IUserPreferenceService.cs
===============================================================================
using PalletManagementSystem.Core.DTOs;
using PalletManagementSystem.Core.Models.Enums;
using System.Threading.Tasks;

namespace PalletManagementSystem.Core.Interfaces.Services
{
    /// <summary>
    /// Service for managing user preferences
    /// </summary>
    public interface IUserPreferenceService
    {
        /// <summary>
        /// Gets preferred division for a user
        /// </summary>
        /// <param name="username">The username</param>
        /// <returns>The preferred division</returns>
        Task<Division> GetPreferredDivisionAsync(string username);

        /// <summary>
        /// Sets preferred division for a user
        /// </summary>
        /// <param name="username">The username</param>
        /// <param name="division">The division</param>
        /// <returns>Task representing the async operation</returns>
        Task<bool> SetPreferredDivisionAsync(string username, Division division);

        /// <summary>
        /// Gets preferred platform for a user within a division
        /// </summary>
        /// <param name="username">The username</param>
        /// <param name="division">The division</param>
        /// <returns>The preferred platform</returns>
        Task<Platform> GetPreferredPlatformAsync(string username, Division division);

        /// <summary>
        /// Sets preferred platform for a user
        /// </summary>
        /// <param name="username">The username</param>
        /// <param name="division">The division</param>
        /// <param name="platform">The platform</param>
        /// <returns>Task representing the async operation</returns>
        Task<bool> SetPreferredPlatformAsync(string username, Division division, Platform platform);

        /// <summary>
        /// Gets whether touch mode is enabled for a user
        /// </summary>
        /// <param name="username">The username</param>
        /// <returns>True if touch mode is enabled, false otherwise</returns>
        Task<bool> GetTouchModeEnabledAsync(string username);

        /// <summary>
        /// Sets whether touch mode is enabled for a user
        /// </summary>
        /// <param name="username">The username</param>
        /// <param name="enabled">Whether touch mode is enabled</param>
        /// <returns>Task representing the async operation</returns>
        Task<bool> SetTouchModeEnabledAsync(string username, bool enabled);

        /// <summary>
        /// Gets the number of items per page for a user
        /// </summary>
        /// <param name="username">The username</param>
        /// <returns>The number of items per page</returns>
        Task<int> GetItemsPerPageAsync(string username);

        /// <summary>
        /// Sets the number of items per page for a user
        /// </summary>
        /// <param name="username">The username</param>
        /// <param name="itemsPerPage">The number of items per page</param>
        /// <returns>Task representing the async operation</returns>
        Task<bool> SetItemsPerPageAsync(string username, int itemsPerPage);

        /// <summary>
        /// Gets the default pallet view for a user
        /// </summary>
        /// <param name="username">The username</param>
        /// <returns>The default pallet view</returns>
        Task<string> GetDefaultPalletViewAsync(string username);

        /// <summary>
        /// Sets the default pallet view for a user
        /// </summary>
        /// <param name="username">The username</param>
        /// <param name="defaultView">The default view</param>
        /// <returns>Task representing the async operation</returns>
        Task<bool> SetDefaultPalletViewAsync(string username, string defaultView);

        /// <summary>
        /// Gets all preferences for a user
        /// </summary>
        /// <param name="username">The username</param>
        /// <returns>The user preferences</returns>
        Task<UserPreferencesDto> GetAllPreferencesAsync(string username);

        /// <summary>
        /// Sets all preferences for a user
        /// </summary>
        /// <param name="username">The username</param>
        /// <param name="preferences">The user preferences</param>
        /// <returns>Task representing the async operation</returns>
        Task<bool> SetAllPreferencesAsync(string username, UserPreferencesDto preferences);

        /// <summary>
        /// Gets the session timeout for a user
        /// </summary>
        /// <param name="username">The username</param>
        /// <returns>The session timeout in minutes</returns>
        Task<int> GetSessionTimeoutAsync(string username);

        /// <summary>
        /// Sets the session timeout for a user
        /// </summary>
        /// <param name="username">The username</param>
        /// <param name="timeoutMinutes">The session timeout in minutes</param>
        /// <returns>Task representing the async operation</returns>
        Task<bool> SetSessionTimeoutAsync(string username, int timeoutMinutes);
    }
}

===============================================================================
File: Mappers\ItemMapper.cs
===============================================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using Microsoft.EntityFrameworkCore;
using PalletManagementSystem.Core.DTOs;
using PalletManagementSystem.Core.Models;

namespace PalletManagementSystem.Core.Mappers
{
    /// <summary>
    /// Provides mapping expressions for Item entities
    /// </summary>
    public static class ItemMapper
    {
        /// <summary>
        /// Creates a projection expression to map Item entities to ItemDto objects
        /// </summary>
        public static Expression<Func<Item, ItemDto>> ProjectToDto()
        {
            return i => new ItemDto
            {
                Id = i.Id,
                ItemNumber = i.ItemNumber,
                PalletId = i.PalletId,
                ManufacturingOrder = i.ManufacturingOrder,
                ManufacturingOrderLine = i.ManufacturingOrderLine,
                ServiceOrder = i.ServiceOrder,
                ServiceOrderLine = i.ServiceOrderLine,
                FinalOrder = i.FinalOrder,
                FinalOrderLine = i.FinalOrderLine,
                ClientCode = i.ClientCode,
                ClientName = i.ClientName,
                Reference = i.Reference,
                Finish = i.Finish,
                Color = i.Color,
                Quantity = i.Quantity,
                QuantityUnit = i.QuantityUnit,
                Weight = i.Weight,
                WeightUnit = i.WeightUnit,
                Width = i.Width,
                WidthUnit = i.WidthUnit,
                Quality = i.Quality,
                Batch = i.Batch,
                CreatedDate = i.CreatedDate,
                CreatedBy = i.CreatedBy,
                Pallet = i.Pallet == null ? null : new PalletDto
                {
                    Id = i.Pallet.Id,
                    PalletNumber = i.Pallet.PalletNumber.Value,
                    IsTemporary = i.Pallet.PalletNumber.IsTemporary,
                    ManufacturingOrder = i.Pallet.ManufacturingOrder,
                    Division = i.Pallet.Division.ToString(),
                    Platform = i.Pallet.Platform.ToString(),
                    UnitOfMeasure = i.Pallet.UnitOfMeasure.ToString(),
                    Quantity = i.Pallet.Quantity,
                    ItemCount = i.Pallet.Items.Count,
                    IsClosed = i.Pallet.IsClosed,
                    CreatedDate = i.Pallet.CreatedDate,
                    ClosedDate = i.Pallet.ClosedDate,
                    CreatedBy = i.Pallet.CreatedBy
                }
            };
        }

        /// <summary>
        /// Creates a projection expression to map Item entities to ItemListDto objects
        /// </summary>
        public static Expression<Func<Item, ItemListDto>> ProjectToListDto()
        {
            return i => new ItemListDto
            {
                Id = i.Id,
                ItemNumber = i.ItemNumber,
                PalletId = i.PalletId,
                ManufacturingOrder = i.ManufacturingOrder,
                ClientCode = i.ClientCode,
                ClientName = i.ClientName,
                Quantity = i.Quantity,
                QuantityUnit = i.QuantityUnit,
                Weight = i.Weight,
                WeightUnit = i.WeightUnit,
                Width = i.Width,
                WidthUnit = i.WidthUnit,
                CreatedDate = i.CreatedDate
            };
        }

        /// <summary>
        /// Creates a projection expression to map Item entities to ItemDetailDto objects
        /// </summary>
        public static Expression<Func<Item, ItemDetailDto>> ProjectToDetailDto()
        {
            return i => new ItemDetailDto
            {
                Id = i.Id,
                ItemNumber = i.ItemNumber,
                PalletId = i.PalletId,
                ManufacturingOrder = i.ManufacturingOrder,
                ManufacturingOrderLine = i.ManufacturingOrderLine,
                ServiceOrder = i.ServiceOrder,
                ServiceOrderLine = i.ServiceOrderLine,
                FinalOrder = i.FinalOrder,
                FinalOrderLine = i.FinalOrderLine,
                ClientCode = i.ClientCode,
                ClientName = i.ClientName,
                Reference = i.Reference,
                Finish = i.Finish,
                Color = i.Color,
                Quantity = i.Quantity,
                QuantityUnit = i.QuantityUnit,
                Weight = i.Weight,
                WeightUnit = i.WeightUnit,
                Width = i.Width,
                WidthUnit = i.WidthUnit,
                Quality = i.Quality,
                Batch = i.Batch,
                CreatedDate = i.CreatedDate,
                CreatedBy = i.CreatedBy,
                Pallet = i.Pallet == null ? null : new PalletInfo
                {
                    Id = i.Pallet.Id,
                    PalletNumber = i.Pallet.PalletNumber.Value,
                    IsClosed = i.Pallet.IsClosed
                }
            };
        }

        /// <summary>
        /// Applies the list projection to a queryable of Item entities
        /// </summary>
        public static IQueryable<ItemListDto> ProjectToListDto(this IQueryable<Item> query)
        {
            return query.Select(ProjectToListDto());
        }

        /// <summary>
        /// Applies the detail projection to a queryable of Item entities
        /// </summary>
        public static IQueryable<ItemDetailDto> ProjectToDetailDto(this IQueryable<Item> query)
        {
            return query.Include(i => i.Pallet).Select(ProjectToDetailDto());
        }

        /// <summary>
        /// Applies the DTO projection to a queryable of Item entities
        /// </summary>
        public static IQueryable<ItemDto> ProjectToDto(this IQueryable<Item> query)
        {
            return query.Include(i => i.Pallet).Select(ProjectToDto());
        }

        /// <summary>
        /// Converts a list of Item list DTOs to an enumerable of ItemDto
        /// </summary>
        public static IEnumerable<ItemDto> ToDto(this IReadOnlyList<ItemListDto> itemListDtos)
        {
            return itemListDtos.Select(i => new ItemDto
            {
                Id = i.Id,
                ItemNumber = i.ItemNumber,
                PalletId = i.PalletId,
                ManufacturingOrder = i.ManufacturingOrder,
                ClientCode = i.ClientCode,
                ClientName = i.ClientName,
                Quantity = i.Quantity,
                QuantityUnit = i.QuantityUnit,
                Weight = i.Weight,
                WeightUnit = i.WeightUnit,
                Width = i.Width,
                WidthUnit = i.WidthUnit,
                CreatedDate = i.CreatedDate
            });
        }

        /// <summary>
        /// Converts a queryable of Item entities to an IEnumerable of ItemDto
        /// </summary>
        public static IEnumerable<ItemDto> ToDto(this IQueryable<Item> query)
        {
            return query.Select(ProjectToDto());
        }
    }
}

===============================================================================
File: Mappers\PalletMapper.cs
===============================================================================
// src/PalletManagementSystem.Core/Mappers/PalletMapper.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using Microsoft.EntityFrameworkCore; // Keep for Include/ThenInclude usage
using PalletManagementSystem.Core.DTOs;
using PalletManagementSystem.Core.Models;

namespace PalletManagementSystem.Core.Mappers
{
    /// <summary>
    /// Provides mapping expressions and extension methods for Pallet entities
    /// </summary>
    public static class PalletMapper
    {
        // --- ProjectToDto remains the same ---
        public static Expression<Func<Pallet, PalletDto>> ProjectToDto()
        {
            return p => new PalletDto
            {
                Id = p.Id,
                PalletNumber = p.PalletNumber.Value,
                IsTemporary = p.PalletNumber.IsTemporary,
                ManufacturingOrder = p.ManufacturingOrder,
                Division = p.Division.ToString(),
                Platform = p.Platform.ToString(),
                UnitOfMeasure = p.UnitOfMeasure.ToString(),
                Quantity = p.Quantity,
                // Performance Note: Be mindful if using p.Items.Count here without Include
                ItemCount = p.Items.Count, // Requires Items to be loaded or counted efficiently by EF
                IsClosed = p.IsClosed,
                CreatedDate = p.CreatedDate,
                ClosedDate = p.ClosedDate,
                CreatedBy = p.CreatedBy
            };
        }

        // --- ProjectToListDto remains the same ---
        public static Expression<Func<Pallet, PalletListDto>> ProjectToListDto()
        {
            return p => new PalletListDto
            {
                Id = p.Id,
                PalletNumber = p.PalletNumber.Value,
                IsTemporary = p.PalletNumber.IsTemporary,
                ManufacturingOrder = p.ManufacturingOrder,
                Division = p.Division.ToString(),
                Platform = p.Platform.ToString(),
                UnitOfMeasure = p.UnitOfMeasure.ToString(),
                Quantity = p.Quantity,
                // Performance Note: Be mindful if using p.Items.Count here without Include
                ItemCount = p.Items.Count, // Requires Items to be loaded or counted efficiently by EF
                IsClosed = p.IsClosed,
                CreatedDate = p.CreatedDate,
                ClosedDate = p.ClosedDate,
                CreatedBy = p.CreatedBy
            };
        }

        // --- MODIFIED ProjectToDetailDto ---
        /// <summary>
        /// Creates a projection expression to map Pallet entities to PalletDetailDto objects,
        /// including detailed item information.
        /// </summary>
        public static Expression<Func<Pallet, PalletDetailDto>> ProjectToDetailDto()
        {
            return p => new PalletDetailDto
            {
                Id = p.Id,
                PalletNumber = p.PalletNumber.Value,
                IsTemporary = p.PalletNumber.IsTemporary,
                ManufacturingOrder = p.ManufacturingOrder,
                Division = p.Division.ToString(),
                Platform = p.Platform.ToString(),
                UnitOfMeasure = p.UnitOfMeasure.ToString(),
                Quantity = p.Quantity,
                ItemCount = p.Items.Count, // Okay here as Items are explicitly included
                IsClosed = p.IsClosed,
                CreatedDate = p.CreatedDate,
                ClosedDate = p.ClosedDate,
                CreatedBy = p.CreatedBy,
                // --- Project Items to ItemDetailDto ---
                Items = p.Items.Select(i => new ItemDetailDto
                {
                    // Map ALL fields from Item entity 'i' to ItemDetailDto
                    Id = i.Id,
                    ItemNumber = i.ItemNumber,
                    PalletId = i.PalletId,
                    ManufacturingOrder = i.ManufacturingOrder,
                    ManufacturingOrderLine = i.ManufacturingOrderLine,
                    ServiceOrder = i.ServiceOrder,
                    ServiceOrderLine = i.ServiceOrderLine,
                    FinalOrder = i.FinalOrder,
                    FinalOrderLine = i.FinalOrderLine,
                    ClientCode = i.ClientCode,
                    ClientName = i.ClientName,
                    Reference = i.Reference, // Include Reference
                    Finish = i.Finish,
                    Color = i.Color,
                    Quantity = i.Quantity,
                    QuantityUnit = i.QuantityUnit,
                    Weight = i.Weight,
                    WeightUnit = i.WeightUnit,
                    Width = i.Width,
                    WidthUnit = i.WidthUnit,
                    Quality = i.Quality,
                    Batch = i.Batch,
                    CreatedDate = i.CreatedDate,
                    CreatedBy = i.CreatedBy, // Include CreatedBy
                    // Pallet info within ItemDetailDto: provide basic info
                    // Avoid circular reference or deep nesting
                    Pallet = new PalletInfo { Id = p.Id, PalletNumber = p.PalletNumber.Value, IsClosed = p.IsClosed }
                }).ToList() // Materialize the list of ItemDetailDto
                // --------------------------------------
            };
        }
        // --- END MODIFIED ProjectToDetailDto ---


        // --- Extension methods ---

        /// <summary>
        /// Applies the DTO projection to a queryable of Pallet entities.
        /// </summary>
        public static IQueryable<PalletDto> ProjectToDto(this IQueryable<Pallet> query)
        {
            // Include Items if ItemCount calculation relies on it loading here
            // return query.Include(p => p.Items).Select(ProjectToDto());
            return query.Select(ProjectToDto()); // Assuming ItemCount can be calculated efficiently
        }

        /// <summary>
        /// Applies the list projection to a queryable of Pallet entities.
        /// </summary>
        public static IQueryable<PalletListDto> ProjectToListDto(this IQueryable<Pallet> query)
        {
            // Include Items if ItemCount calculation relies on it loading here
            // return query.Include(p => p.Items).Select(ProjectToListDto());
            return query.Select(ProjectToListDto()); // Assuming ItemCount can be calculated efficiently
        }

        /// <summary>
        /// Applies the detail projection (including detailed items) to a queryable of Pallet entities.
        /// Ensures Items navigation property is loaded before projecting.
        /// </summary>
        public static IQueryable<PalletDetailDto> ProjectToDetailDto(this IQueryable<Pallet> query)
        {
            // *** ENSURE Include(p => p.Items) is called here ***
            // This loads the related Item entities so the Select projection can access them.
            return query.Include(p => p.Items).Select(ProjectToDetailDto());
        }


        // --- ToDto extension methods (remain the same conceptually) ---
        public static IEnumerable<PalletDto> ToDto(this IReadOnlyList<PalletListDto> palletListDtos)
        {
            // Implement the mapping from PalletListDto to PalletDto if needed
            return palletListDtos.Select(p => new PalletDto
            {
                Id = p.Id,
                PalletNumber = p.PalletNumber,
                IsTemporary = p.IsTemporary,
                ManufacturingOrder = p.ManufacturingOrder,
                Division = p.Division,
                Platform = p.Platform,
                UnitOfMeasure = p.UnitOfMeasure,
                Quantity = p.Quantity,
                ItemCount = p.ItemCount,
                IsClosed = p.IsClosed,
                CreatedDate = p.CreatedDate,
                ClosedDate = p.ClosedDate,
                CreatedBy = p.CreatedBy
                // PalletDto does not have Items collection
            });
        }
        public static IEnumerable<PalletDto> ToDto(this IQueryable<Pallet> query)
        {
            return query.ProjectToDto().ToList(); // Materialize the query
        }
    }
}

===============================================================================
File: Mappers\QueryableMapperExtensions.cs
===============================================================================
using System;
using System.Linq;
using System.Linq.Expressions;
using System.Threading.Tasks;
using System.Collections.Generic;
using PalletManagementSystem.Core.Interfaces.Repositories;

namespace PalletManagementSystem.Core.Mappers
{
    /// <summary>
    /// Extensions for mapping IQuery results to DTOs
    /// </summary>
    public static class QueryableMapperExtensions
    {
        /// <summary>
        /// Projects a query to a list of DTOs
        /// </summary>
        /// <typeparam name="TEntity">The entity type</typeparam>
        /// <typeparam name="TDto">The DTO type</typeparam>
        /// <param name="query">The query</param>
        /// <param name="selector">The selector expression</param>
        /// <returns>A list of mapped DTOs</returns>
        public static IReadOnlyList<TDto> ProjectToList<TEntity, TDto>(
            this IQuery<TEntity> query,
            Expression<Func<TEntity, TDto>> selector) where TEntity : class
        {
            // Apply the selector to entities after they're loaded
            // This is a simplified version that loads entities first then maps
            var entities = query.ToList();
            var selectorCompiled = selector.Compile();
            return entities.Select(selectorCompiled).ToList();
        }

        /// <summary>
        /// Projects a query to a DTO
        /// </summary>
        /// <typeparam name="TEntity">The entity type</typeparam>
        /// <typeparam name="TDto">The DTO type</typeparam>
        /// <param name="query">The query</param>
        /// <param name="selector">The selector expression</param>
        /// <returns>The mapped DTO</returns>
        public static TDto ProjectToFirst<TEntity, TDto>(
            this IQuery<TEntity> query,
            Expression<Func<TEntity, TDto>> selector) where TEntity : class
        {
            // Apply the selector to the entity after it's loaded
            var entity = query.FirstOrDefault();
            if (entity == null)
                return default;

            var selectorCompiled = selector.Compile();
            return selectorCompiled(entity);
        }
    }
}

===============================================================================
File: Models\Item.cs
===============================================================================
using System;
using PalletManagementSystem.Core.Exceptions;

namespace PalletManagementSystem.Core.Models
{
    /// <summary>
    /// Represents an item on a pallet
    /// </summary>
    public class Item
    {
        // Special client indicators - centralized here
        private const string SPECIAL_CLIENT_CODE = "280898";
        private const string SPECIAL_CLIENT_NAME = "Special Client HB";

        /// <summary>
        /// Gets the item ID
        /// </summary>
        public int Id { get; protected set; }

        /// <summary>
        /// Gets the unique item number
        /// </summary>
        public string ItemNumber { get; protected set; }

        /// <summary>
        /// Gets or sets the pallet ID this item belongs to
        /// </summary>
        public int PalletId { get; set; }

        /// <summary>
        /// Gets or sets the pallet this item belongs to
        /// </summary>
        public Pallet Pallet { get; set; }

        #region Order Information

        /// <summary>
        /// Gets the manufacturing order
        /// </summary>
        public string ManufacturingOrder { get; protected set; }

        /// <summary>
        /// Gets the manufacturing order line
        /// </summary>
        public string ManufacturingOrderLine { get; protected set; }

        /// <summary>
        /// Gets the service order
        /// </summary>
        public string ServiceOrder { get; protected set; }

        /// <summary>
        /// Gets the service order line
        /// </summary>
        public string ServiceOrderLine { get; protected set; }

        /// <summary>
        /// Gets the final order
        /// </summary>
        public string FinalOrder { get; protected set; }

        /// <summary>
        /// Gets the final order line
        /// </summary>
        public string FinalOrderLine { get; protected set; }

        #endregion

        #region Client Information

        /// <summary>
        /// Gets the client code
        /// </summary>
        public string ClientCode { get; protected set; }

        /// <summary>
        /// Gets the client name
        /// </summary>
        public string ClientName { get; protected set; }

        #endregion

        #region Product Information

        /// <summary>
        /// Gets the reference
        /// </summary>
        public string Reference { get; protected set; }

        /// <summary>
        /// Gets the finish
        /// </summary>
        public string Finish { get; protected set; }

        /// <summary>
        /// Gets the color
        /// </summary>
        public string Color { get; protected set; }

        /// <summary>
        /// Gets the quantity
        /// </summary>
        public decimal Quantity { get; protected set; }

        /// <summary>
        /// Gets the quantity unit
        /// </summary>
        public string QuantityUnit { get; protected set; }

        #endregion

        #region Physical Properties (Editable)

        /// <summary>
        /// Gets or sets the weight (editable)
        /// </summary>
        public decimal Weight { get; protected set; }

        /// <summary>
        /// Gets the weight unit
        /// </summary>
        public string WeightUnit { get; protected set; }

        /// <summary>
        /// Gets or sets the width (editable)
        /// </summary>
        public decimal Width { get; protected set; }

        /// <summary>
        /// Gets the width unit
        /// </summary>
        public string WidthUnit { get; protected set; }

        /// <summary>
        /// Gets or sets the quality (editable)
        /// </summary>
        public string Quality { get; protected set; }

        /// <summary>
        /// Gets or sets the batch (editable)
        /// </summary>
        public string Batch { get; protected set; }

        #endregion

        /// <summary>
        /// Gets the created date
        /// </summary>
        public DateTime CreatedDate { get; protected set; }

        /// <summary>
        /// Gets the created by username
        /// </summary>
        public string CreatedBy { get; protected set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="Item"/> class
        /// Private constructor for EF Core
        /// </summary>
        private Item() { }

        /// <summary>
        /// Initializes a new instance of the <see cref="Item"/> class
        /// </summary>
        /// <param name="itemNumber">The item number</param>
        /// <param name="manufacturingOrder">The manufacturing order</param>
        /// <param name="manufacturingOrderLine">The manufacturing order line</param>
        /// <param name="serviceOrder">The service order</param>
        /// <param name="serviceOrderLine">The service order line</param>
        /// <param name="finalOrder">The final order</param>
        /// <param name="finalOrderLine">The final order line</param>
        /// <param name="clientCode">The client code</param>
        /// <param name="clientName">The client name</param>
        /// <param name="reference">The reference</param>
        /// <param name="finish">The finish</param>
        /// <param name="color">The color</param>
        /// <param name="quantity">The quantity</param>
        /// <param name="quantityUnit">The quantity unit</param>
        /// <param name="weight">The weight</param>
        /// <param name="weightUnit">The weight unit</param>
        /// <param name="width">The width</param>
        /// <param name="widthUnit">The width unit</param>
        /// <param name="quality">The quality</param>
        /// <param name="batch">The batch</param>
        /// <param name="createdBy">The username of the creator</param>
        public Item(
            string itemNumber,
            string manufacturingOrder,
            string manufacturingOrderLine,
            string serviceOrder,
            string serviceOrderLine,
            string finalOrder,
            string finalOrderLine,
            string clientCode,
            string clientName,
            string reference,
            string finish,
            string color,
            decimal quantity,
            string quantityUnit,
            decimal weight,
            string weightUnit,
            decimal width,
            string widthUnit,
            string quality,
            string batch,
            string createdBy)
        {
            ValidateConstructorParameters(
                itemNumber,
                manufacturingOrder,
                quantity,
                weight,
                width,
                createdBy);

            ItemNumber = itemNumber;
            ManufacturingOrder = manufacturingOrder;
            ManufacturingOrderLine = manufacturingOrderLine;
            ServiceOrder = serviceOrder;
            ServiceOrderLine = serviceOrderLine;
            FinalOrder = finalOrder;
            FinalOrderLine = finalOrderLine;
            ClientCode = clientCode;
            ClientName = clientName;
            Reference = reference;
            Finish = finish;
            Color = color;
            Quantity = quantity;
            QuantityUnit = quantityUnit;
            Weight = weight;
            WeightUnit = weightUnit;
            Width = width;
            WidthUnit = widthUnit;
            Quality = quality;
            Batch = batch;
            CreatedDate = DateTime.Now;
            CreatedBy = createdBy;
        }

        private void ValidateConstructorParameters(
            string itemNumber,
            string manufacturingOrder,
            decimal quantity,
            decimal weight,
            decimal width,
            string createdBy)
        {
            if (string.IsNullOrWhiteSpace(itemNumber))
            {
                throw new ArgumentException("Item number cannot be null or empty", nameof(itemNumber));
            }

            if (string.IsNullOrWhiteSpace(manufacturingOrder))
            {
                throw new ArgumentException("Manufacturing order cannot be null or empty", nameof(manufacturingOrder));
            }

            if (string.IsNullOrWhiteSpace(createdBy))
            {
                throw new ArgumentException("CreatedBy cannot be null or empty", nameof(createdBy));
            }

            if (quantity <= 0)
            {
                throw new ArgumentException("Quantity must be greater than zero", nameof(quantity));
            }

            if (weight < 0)
            {
                throw new ArgumentException("Weight cannot be negative", nameof(weight));
            }

            if (width < 0)
            {
                throw new ArgumentException("Width cannot be negative", nameof(width));
            }
        }

        /// <summary>
        /// Updates the editable properties of the item
        /// </summary>
        /// <param name="weight">The new weight</param>
        /// <param name="width">The new width</param>
        /// <param name="quality">The new quality</param>
        /// <param name="batch">The new batch</param>
        public void Update(decimal weight, decimal width, string quality, string batch)
        {
            EnsurePalletNotClosed();
            ValidateUpdateParameters(weight, width, batch);

            Weight = weight;
            Width = width;
            Quality = quality;
            Batch = batch;
        }

        /// <summary>
        /// Assigns this item to a pallet
        /// </summary>
        /// <param name="pallet">The pallet to assign to</param>
        public void AssignToPallet(Pallet pallet)
        {
            if (pallet == null)
            {
                throw new ArgumentNullException(nameof(pallet));
            }

            if (pallet.IsClosed)
            {
                throw new PalletClosedException("Cannot assign items to a closed pallet");
            }

            if (Pallet != null && Pallet.IsClosed)
            {
                throw new PalletClosedException("Cannot reassign items from a closed pallet");
            }

            // Set the pallet and update the ID
            Pallet = pallet;
            PalletId = pallet.Id;

            // Let the pallet know about this item
            pallet.AddItem(this);
        }

        /// <summary>
        /// Removes this item from its current pallet
        /// </summary>
        public void RemoveFromPallet()
        {
            if (Pallet == null)
            {
                return;
            }

            if (Pallet.IsClosed)
            {
                throw new PalletClosedException("Cannot remove items from a closed pallet");
            }

            // Let the pallet know this item is being removed
            Pallet.RemoveItem(this);

            // Clear the pallet references
            Pallet = null;
            PalletId = 0;
        }

        /// <summary>
        /// Moves this item from its current pallet to another pallet
        /// </summary>
        /// <param name="targetPallet">The target pallet</param>
        public void MoveToPallet(Pallet targetPallet)
        {
            if (targetPallet == null)
            {
                throw new ArgumentNullException(nameof(targetPallet));
            }

            // Remove from current pallet if any
            RemoveFromPallet();

            // Assign to the target pallet
            AssignToPallet(targetPallet);
        }

        /// <summary>
        /// Checks if the item belongs to a special client
        /// </summary>
        /// <returns>True if the client is special, false otherwise</returns>
        public bool IsSpecialClient()
        {
            return ClientCode == SPECIAL_CLIENT_CODE && ClientName == SPECIAL_CLIENT_NAME;
        }

        private void EnsurePalletNotClosed()
        {
            if (Pallet != null && Pallet.IsClosed)
            {
                throw new PalletClosedException("Cannot update items on a closed pallet");
            }
        }

        private void ValidateUpdateParameters(decimal weight, decimal width, string batch)
        {
            if (weight < 0)
            {
                throw new ItemValidationException("Weight cannot be negative");
            }

            if (width < 0)
            {
                throw new ItemValidationException("Width cannot be negative");
            }

            if (string.IsNullOrWhiteSpace(batch))
            {
                throw new ItemValidationException("Batch cannot be empty");
            }
        }
    }
}

===============================================================================
File: Models\PagedResult.cs
===============================================================================
using System;
using System.Collections.Generic;

namespace PalletManagementSystem.Core.Models
{
    /// <summary>
    /// Represents a page of results from a repository query
    /// </summary>
    /// <typeparam name="T">The entity type</typeparam>
    public class PagedResult<T>
    {
        /// <summary>
        /// Gets the items in the current page
        /// </summary>
        public IReadOnlyList<T> Items { get; }

        /// <summary>
        /// Gets the total count of items across all pages
        /// </summary>
        public int TotalCount { get; }

        /// <summary>
        /// Gets the current page number (1-based)
        /// </summary>
        public int PageNumber { get; }

        /// <summary>
        /// Gets the page size
        /// </summary>
        public int PageSize { get; }

        /// <summary>
        /// Gets the total number of pages
        /// </summary>
        public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);

        /// <summary>
        /// Gets a value indicating whether there is a previous page
        /// </summary>
        public bool HasPreviousPage => PageNumber > 1;

        /// <summary>
        /// Gets a value indicating whether there is a next page
        /// </summary>
        public bool HasNextPage => PageNumber < TotalPages;

        /// <summary>
        /// Initializes a new instance of the <see cref="PagedResult{T}"/> class
        /// </summary>
        /// <param name="items">The items in the current page</param>
        /// <param name="totalCount">The total count of items across all pages</param>
        /// <param name="pageNumber">The current page number (1-based)</param>
        /// <param name="pageSize">The page size</param>
        public PagedResult(IReadOnlyList<T> items, int totalCount, int pageNumber, int pageSize)
        {
            Items = items;
            TotalCount = totalCount;
            PageNumber = pageNumber;
            PageSize = pageSize;
        }
    }
}

===============================================================================
File: Models\Pallet.cs
===============================================================================
using System;
using System.Collections.Generic;
using System.Linq;
using PalletManagementSystem.Core.Exceptions;
using PalletManagementSystem.Core.Models.Enums;
using PalletManagementSystem.Core.Models.ValueObjects;

namespace PalletManagementSystem.Core.Models
{
    /// <summary>
    /// Represents a pallet in the system
    /// </summary>
    public class Pallet
    {
        private readonly List<Item> _items = new List<Item>();

        /// <summary>
        /// Gets the pallet ID
        /// </summary>
        public int Id { get; protected set; }

        /// <summary>
        /// Gets the pallet number
        /// </summary>
        public PalletNumber PalletNumber { get; protected set; }

        /// <summary>
        /// Gets the manufacturing order associated with this pallet
        /// </summary>
        public string ManufacturingOrder { get; protected set; }

        /// <summary>
        /// Gets the division this pallet belongs to
        /// </summary>
        public Division Division { get; protected set; }

        /// <summary>
        /// Gets the platform this pallet is assigned to
        /// </summary>
        public Platform Platform { get; protected set; }

        /// <summary>
        /// Gets the unit of measure for this pallet
        /// </summary>
        public UnitOfMeasure UnitOfMeasure { get; protected set; }

        /// <summary>
        /// Gets the total quantity on this pallet
        /// </summary>
        public decimal Quantity { get; protected set; }

        /// <summary>
        /// Gets the number of items on this pallet
        /// </summary>
        public int ItemCount => _items.Count;

        /// <summary>
        /// Gets a value indicating whether this pallet is closed
        /// </summary>
        public bool IsClosed { get; protected set; }

        /// <summary>
        /// Gets the date and time when this pallet was created
        /// </summary>
        public DateTime CreatedDate { get; protected set; }

        /// <summary>
        /// Gets the date and time when this pallet was closed
        /// </summary>
        public DateTime? ClosedDate { get; protected set; }

        /// <summary>
        /// Gets the username of the person who created this pallet
        /// </summary>
        public string CreatedBy { get; protected set; }

        /// <summary>
        /// Gets a read-only collection of items on this pallet
        /// </summary>
        public IReadOnlyCollection<Item> Items => _items.AsReadOnly();

        /// <summary>
        /// Initializes a new instance of the <see cref="Pallet"/> class
        /// Private constructor for EF Core
        /// </summary>
        private Pallet() { }

        /// <summary>
        /// Initializes a new instance of the <see cref="Pallet"/> class
        /// </summary>
        /// <param name="palletNumber">The pallet number</param>
        /// <param name="manufacturingOrder">The manufacturing order</param>
        /// <param name="division">The division</param>
        /// <param name="platform">The platform</param>
        /// <param name="unitOfMeasure">The unit of measure</param>
        /// <param name="createdBy">Username of creator</param>
        public Pallet(
            PalletNumber palletNumber,
            string manufacturingOrder,
            Division division,
            Platform platform,
            UnitOfMeasure unitOfMeasure,
            string createdBy)
        {
            ValidateConstructorParameters(
                palletNumber,
                manufacturingOrder,
                division,
                platform,
                createdBy);

            PalletNumber = palletNumber;
            ManufacturingOrder = manufacturingOrder;
            Division = division;
            Platform = platform;
            UnitOfMeasure = unitOfMeasure;
            CreatedBy = createdBy;
            CreatedDate = DateTime.Now;
            IsClosed = false;
            Quantity = 0;
        }

        private void ValidateConstructorParameters(
            PalletNumber palletNumber,
            string manufacturingOrder,
            Division division,
            Platform platform,
            string createdBy)
        {
            if (palletNumber == null)
            {
                throw new ArgumentNullException(nameof(palletNumber));
            }

            if (string.IsNullOrWhiteSpace(manufacturingOrder))
            {
                throw new ArgumentException("Manufacturing order cannot be null or empty", nameof(manufacturingOrder));
            }

            if (string.IsNullOrWhiteSpace(createdBy))
            {
                throw new ArgumentException("CreatedBy cannot be null or empty", nameof(createdBy));
            }
        }

        /// <summary>
        /// Add an item to this pallet
        /// </summary>
        /// <param name="item">The item to add</param>
        public void AddItem(Item item)
        {
            if (item == null)
            {
                throw new ArgumentNullException(nameof(item));
            }

            if (IsClosed)
            {
                throw new PalletClosedException("Cannot add items to a closed pallet");
            }

            // Only add the item if it's not already on this pallet
            if (!_items.Contains(item))
            {
                _items.Add(item);
                RecalculateQuantity();
            }
        }

        /// <summary>
        /// Remove an item from this pallet
        /// </summary>
        /// <param name="item">The item to remove</param>
        public void RemoveItem(Item item)
        {
            if (item == null)
            {
                throw new ArgumentNullException(nameof(item));
            }

            if (IsClosed)
            {
                throw new PalletClosedException("Cannot remove items from a closed pallet");
            }

            _items.Remove(item);
            RecalculateQuantity();
        }

        /// <summary>
        /// Closes the pallet and assigns a permanent number if needed
        /// </summary>
        /// <param name="permanentNumber">The permanent pallet number to assign (if needed)</param>
        public void Close(PalletNumber permanentNumber = null)
        {
            if (IsClosed)
            {
                throw new InvalidOperationException("Pallet is already closed");
            }

            // If pallet has a temporary number and no permanent number was provided, throw exception
            if (PalletNumber.IsTemporary && permanentNumber == null)
            {
                throw new ArgumentNullException(nameof(permanentNumber),
                    "A permanent pallet number must be provided when closing a pallet with a temporary number");
            }

            // Assign permanent number if needed
            if (PalletNumber.IsTemporary)
            {
                PalletNumber = permanentNumber;
            }

            IsClosed = true;
            ClosedDate = DateTime.Now;
        }

        /// <summary>
        /// Recalculates the total quantity on this pallet
        /// </summary>
        private void RecalculateQuantity()
        {
            Quantity = _items.Sum(i => i.Quantity);
        }
    }
}

===============================================================================
File: Models\Enums\EnumExtensions.cs
===============================================================================
using System;
using System.ComponentModel;
using System.Linq;
using System.Reflection;

namespace PalletManagementSystem.Core.Extensions
{
    /// <summary>
    /// Extension methods for enums to work with Description attributes
    /// </summary>
    public static class EnumExtensions
    {
        /// <summary>
        /// Gets the description attribute value for an enum value
        /// </summary>
        /// <typeparam name="T">The enum type</typeparam>
        /// <param name="value">The enum value</param>
        /// <returns>The description or the enum name if no description is found</returns>
        public static string GetDescription<T>(this T value) where T : struct, Enum
        {
            var field = value.GetType().GetField(value.ToString());

            if (field == null)
                return value.ToString();

            var attribute = field.GetCustomAttribute<DescriptionAttribute>();
            return attribute?.Description ?? value.ToString();
        }

        /// <summary>
        /// Gets the enum value from a description
        /// </summary>
        /// <typeparam name="T">The enum type</typeparam>
        /// <param name="description">The description to look for</param>
        /// <returns>The enum value or default if not found</returns>
        public static T GetValueFromDescription<T>(string description) where T : struct, Enum
        {
            foreach (var field in typeof(T).GetFields())
            {
                if (field.GetCustomAttribute(typeof(DescriptionAttribute)) is DescriptionAttribute attribute)
                {
                    if (attribute.Description == description)
                        return (T)field.GetValue(null);
                }
                else if (field.Name == description)
                {
                    return (T)field.GetValue(null);
                }
            }

            // If no match is found, try to directly parse the enum
            if (Enum.TryParse<T>(description, out T result))
            {
                return result;
            }

            throw new ArgumentException($"'{description}' is not a valid description or value for {typeof(T).Name}");
        }

        /// <summary>
        /// Gets all values of an enum
        /// </summary>
        /// <typeparam name="T">The enum type</typeparam>
        /// <returns>Array of all enum values</returns>
        public static T[] GetAllValues<T>() where T : struct, Enum
        {
            return Enum.GetValues(typeof(T)).Cast<T>().ToArray();
        }

        /// <summary>
        /// Gets all descriptions for an enum type
        /// </summary>
        /// <typeparam name="T">The enum type</typeparam>
        /// <returns>Array of all descriptions</returns>
        public static string[] GetAllDescriptions<T>() where T : struct, Enum
        {
            return GetAllValues<T>().Select(v => v.GetDescription()).ToArray();
        }
    }
}

===============================================================================
File: Models\Enums\Enums.cs
===============================================================================
using System.ComponentModel;

namespace PalletManagementSystem.Core.Models.Enums
{
    /// <summary>
    /// Represents the different divisions in the company
    /// </summary>
    public enum Division
    {
        /// <summary>
        /// Manufacturing Division
        /// </summary>
        [Description("Manufacturing")]
        MA,

        /// <summary>
        /// Technical Center Division
        /// </summary>
        [Description("Technical Center")]
        TC
    }

    /// <summary>
    /// Represents platforms within divisions
    /// </summary>
    public enum Platform
    {
        /// <summary>
        /// Technology platform 1 (available in both divisions)
        /// </summary>
        [Description("TEC1")]
        TEC1,

        /// <summary>
        /// Technology platform 2 (Manufacturing division only)
        /// </summary>
        [Description("TEC2")]
        TEC2,

        /// <summary>
        /// Technology platform 3 (Technical Center division only)
        /// </summary>
        [Description("TEC3")]
        TEC3,

        /// <summary>
        /// Technology platform 4I (Manufacturing division only)
        /// </summary>
        [Description("TEC4I")]
        TEC4I,

        /// <summary>
        /// Technology platform 5 (Technical Center division only)
        /// </summary>
        [Description("TEC5")]
        TEC5
    }

    /// <summary>
    /// Represents units of measure for pallets and items
    /// </summary>
    public enum UnitOfMeasure
    {
        /// <summary>
        /// Piece
        /// </summary>
        [Description("Piece")]
        PC,

        /// <summary>
        /// Kilogram
        /// </summary>
        [Description("Kilogram")]
        KG,

        /// <summary>
        /// Box
        /// </summary>
        [Description("Box")]
        BOX,

        /// <summary>
        /// Roll
        /// </summary>
        [Description("Roll")]
        ROLL
    }
}

===============================================================================
File: Models\ValueObjects\PalletNumber.cs
===============================================================================
using System;
using System.Text.RegularExpressions;
using PalletManagementSystem.Core.Models.Enums;

namespace PalletManagementSystem.Core.Models.ValueObjects
{
    /// <summary>
    /// Value object representing a pallet number
    /// </summary>
    public class PalletNumber : IEquatable<PalletNumber>
    {
        private static readonly Regex TemporaryPattern = new Regex(@"^TEMP\d{3}$", RegexOptions.Compiled);
        private static readonly Regex ManufacturingPattern = new Regex(@"^P8\d{6}$", RegexOptions.Compiled);
        private static readonly Regex TechnicalCenterPattern = new Regex(@"^47\d{6}$", RegexOptions.Compiled);

        /// <summary>
        /// Gets the value of the pallet number
        /// </summary>
        public string Value { get; }

        /// <summary>
        /// Gets a value indicating whether this is a temporary pallet number
        /// </summary>
        public bool IsTemporary { get; }

        /// <summary>
        /// Gets the division this pallet number belongs to
        /// </summary>
        public Division Division { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="PalletNumber"/> class
        /// </summary>
        /// <param name="value">The pallet number value</param>
        /// <param name="isTemporary">Indicates if this is a temporary number</param>
        /// <param name="division">The division this pallet belongs to</param>
        public PalletNumber(string value, bool isTemporary, Division division)
        {
            if (string.IsNullOrWhiteSpace(value))
            {
                throw new ArgumentException("Pallet number cannot be null or empty", nameof(value));
            }

            // Validate pallet number format
            if (!ValidateFormat(value, isTemporary, division))
            {
                throw new ArgumentException($"Invalid pallet number format: {value} for division {division} and isTemporary={isTemporary}", nameof(value));
            }

            Value = value;
            IsTemporary = isTemporary;
            Division = division;
        }

        /// <summary>
        /// Creates a new temporary pallet number
        /// </summary>
        /// <param name="sequenceNumber">The sequence number to use</param>
        /// <param name="division">The division</param>
        /// <returns>A new temporary pallet number</returns>
        public static PalletNumber CreateTemporary(int sequenceNumber, Division division)
        {
            if (sequenceNumber <= 0)
            {
                throw new ArgumentException("Sequence number must be positive", nameof(sequenceNumber));
            }

            return new PalletNumber($"TEMP-{sequenceNumber:000}", true, division);
        }

        /// <summary>
        /// Creates a permanent pallet number based on division format rules
        /// </summary>
        /// <param name="sequenceNumber">The sequence number</param>
        /// <param name="division">The division</param>
        /// <returns>A new permanent pallet number</returns>
        public static PalletNumber CreatePermanent(int sequenceNumber, Division division)
        {
            if (sequenceNumber <= 0)
            {
                throw new ArgumentException("Sequence number must be positive", nameof(sequenceNumber));
            }

            string value;
            switch (division)
            {
                case Division.MA:
                    value = $"P8{sequenceNumber:00000}";  // Manufacturing uses P8 prefix
                    break;
                case Division.TC:
                    value = $"47{sequenceNumber:00000}";  // Technical Center uses 47 prefix
                    break;
                default:
                    throw new ArgumentException($"Unsupported division: {division}", nameof(division));
            }

            return new PalletNumber(value, false, division);
        }

        /// <summary>
        /// Validates the format of a pallet number
        /// </summary>
        /// <param name="value">The pallet number to validate</param>
        /// <param name="isTemporary">Whether it's a temporary number</param>
        /// <param name="division">The division</param>
        /// <returns>True if the format is valid, false otherwise</returns>
        private bool ValidateFormat(string value, bool isTemporary, Division division)
        {
            if (isTemporary)
            {
                return TemporaryPattern.IsMatch(value);
            }

            switch (division)
            {
                case Division.MA:
                    return ManufacturingPattern.IsMatch(value);
                case Division.TC:
                    return TechnicalCenterPattern.IsMatch(value);
                default:
                    return false;
            }
        }

        /// <summary>
        /// Try to parse a pallet number string into a PalletNumber object
        /// </summary>
        /// <param name="value">The string value to parse</param>
        /// <param name="palletNumber">The resulting pallet number if successful</param>
        /// <returns>True if parsing was successful, false otherwise</returns>
        public static bool TryParse(string value, out PalletNumber palletNumber)
        {
            palletNumber = null;

            if (string.IsNullOrWhiteSpace(value))
            {
                return false;
            }

            // Check for temporary number format
            if (TemporaryPattern.IsMatch(value))
            {
                // Temporary numbers can be used for any division
                palletNumber = new PalletNumber(value, true, Division.MA);
                return true;
            }

            // Check for MA division format
            if (ManufacturingPattern.IsMatch(value))
            {
                palletNumber = new PalletNumber(value, false, Division.MA);
                return true;
            }

            // Check for TC division format
            if (TechnicalCenterPattern.IsMatch(value))
            {
                palletNumber = new PalletNumber(value, false, Division.TC);
                return true;
            }

            return false;
        }

        /// <inheritdoc/>
        public override string ToString()
        {
            return Value;
        }

        /// <inheritdoc/>
        public override bool Equals(object obj)
        {
            return Equals(obj as PalletNumber);
        }

        /// <inheritdoc/>
        public bool Equals(PalletNumber other)
        {
            if (other is null)
            {
                return false;
            }

            return Value == other.Value &&
                   IsTemporary == other.IsTemporary &&
                   Division == other.Division;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return HashCode.Combine(Value, IsTemporary, Division);
        }

        /// <summary>
        /// Determines whether two pallet numbers are equal
        /// </summary>
        /// <param name="left">The first pallet number</param>
        /// <param name="right">The second pallet number</param>
        /// <returns>True if equal, false otherwise</returns>
        public static bool operator ==(PalletNumber left, PalletNumber right)
        {
            if (left is null)
            {
                return right is null;
            }

            return left.Equals(right);
        }

        /// <summary>
        /// Determines whether two pallet numbers are not equal
        /// </summary>
        /// <param name="left">The first pallet number</param>
        /// <param name="right">The second pallet number</param>
        /// <returns>True if not equal, false otherwise</returns>
        public static bool operator !=(PalletNumber left, PalletNumber right)
        {
            return !(left == right);
        }

        // HashCode helper for C# < 8.0
        private static class HashCode
        {
            public static int Combine(object obj1, object obj2, object obj3)
            {
                unchecked
                {
                    int hash = 17;
                    hash = hash * 23 + (obj1?.GetHashCode() ?? 0);
                    hash = hash * 23 + (obj2?.GetHashCode() ?? 0);
                    hash = hash * 23 + (obj3?.GetHashCode() ?? 0);
                    return hash;
                }
            }
        }
    }
}

===============================================================================
File: Services\ItemService.cs
===============================================================================
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using PalletManagementSystem.Core.DTOs;
using PalletManagementSystem.Core.Exceptions;
using PalletManagementSystem.Core.Interfaces.Repositories;
using PalletManagementSystem.Core.Interfaces.Services;
using PalletManagementSystem.Core.Models;

namespace PalletManagementSystem.Core.Services
{
    public class ItemService : IItemService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IItemRepository _itemRepository;
        private readonly IPalletRepository _palletRepository;
        private readonly IPrinterService _printerService;
        private readonly ITransactionManager _transactionManager;
        private readonly ILogger<ItemService> _logger;

        public ItemService(
            IUnitOfWork unitOfWork,
            IItemRepository itemRepository,
            IPalletRepository palletRepository,
            IPrinterService printerService,
            ITransactionManager transactionManager,
            ILogger<ItemService> logger)
        {
            _unitOfWork = unitOfWork ?? throw new ArgumentNullException(nameof(unitOfWork));
            _itemRepository = itemRepository ?? throw new ArgumentNullException(nameof(itemRepository));
            _palletRepository = palletRepository ?? throw new ArgumentNullException(nameof(palletRepository));
            _printerService = printerService ?? throw new ArgumentNullException(nameof(printerService));
            _transactionManager = transactionManager ?? throw new ArgumentNullException(nameof(transactionManager));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task<ItemListDto> GetItemByIdAsync(int id, CancellationToken cancellationToken = default)
        {
            try
            {
                return await _itemRepository.GetItemListByIdAsync(id, cancellationToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error retrieving item with ID {id}");
                throw;
            }
        }

        public async Task<ItemDetailDto> GetItemDetailByIdAsync(int id, CancellationToken cancellationToken = default)
        {
            try
            {
                return await _itemRepository.GetItemDetailByIdAsync(id, cancellationToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error retrieving item detail with ID {id}");
                throw;
            }
        }

        public async Task<ItemListDto> GetItemByNumberAsync(string itemNumber, CancellationToken cancellationToken = default)
        {
            try
            {
                return await _itemRepository.GetItemListByNumberAsync(itemNumber, cancellationToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error retrieving item with number {itemNumber}");
                throw;
            }
        }

        public async Task<IEnumerable<ItemListDto>> GetItemsByPalletIdAsync(int palletId, CancellationToken cancellationToken = default)
        {
            try
            {
                return await _itemRepository.GetItemsByPalletIdAsync(palletId, cancellationToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error retrieving items for pallet ID {palletId}");
                throw;
            }
        }

        public async Task<ItemDto> CreateItemAsync(ItemDto itemDto, int palletId, string username, CancellationToken cancellationToken = default)
        {
            return await _transactionManager.ExecuteInTransactionWithIsolationAsync(async (token) =>
            {
                var pallet = await _unitOfWork.PalletRepository.GetByIdAsync(palletId, token);
                if (pallet == null)
                {
                    throw new DomainException($"Pallet with ID {palletId} not found");
                }

                if (pallet.IsClosed)
                {
                    throw new PalletClosedException($"Cannot add items to closed pallet {pallet.PalletNumber.Value}");
                }

                // Generate item number if not provided
                if (string.IsNullOrWhiteSpace(itemDto.ItemNumber))
                {
                    itemDto.ItemNumber = await _itemRepository.GetNextItemNumberAsync(token);
                }

                var item = new Item(
                    itemDto.ItemNumber,
                    itemDto.ManufacturingOrder,
                    itemDto.ManufacturingOrderLine,
                    itemDto.ServiceOrder,
                    itemDto.ServiceOrderLine,
                    itemDto.FinalOrder,
                    itemDto.FinalOrderLine,
                    itemDto.ClientCode,
                    itemDto.ClientName,
                    itemDto.Reference,
                    itemDto.Finish,
                    itemDto.Color,
                    itemDto.Quantity,
                    itemDto.QuantityUnit,
                    itemDto.Weight,
                    itemDto.WeightUnit,
                    itemDto.Width,
                    itemDto.WidthUnit,
                    itemDto.Quality,
                    itemDto.Batch,
                    username);

                // Assign to pallet
                item.AssignToPallet(pallet);

                await _unitOfWork.ItemRepository.AddAsync(item, token);

                // Return the DTO
                return itemDto;
            }, cancellationToken, IsolationLevel.ReadCommitted);
        }

        public async Task<ItemDetailDto> UpdateItemAsync(int itemId, UpdateItemDto updateDto, CancellationToken cancellationToken = default)
        {
            return await _transactionManager.ExecuteInTransactionWithIsolationAsync(async (token) =>
            {
                var item = await _unitOfWork.ItemRepository.GetByIdWithPalletAsync(itemId, token);
                if (item == null)
                {
                    throw new DomainException($"Item with ID {itemId} not found");
                }

                item.Update(
                    updateDto.Weight,
                    updateDto.Width,
                    updateDto.Quality,
                    updateDto.Batch);

                await _unitOfWork.ItemRepository.UpdateAsync(item, token);

                // Return the updated item
                return await _itemRepository.GetItemDetailByIdAsync(itemId, token);
            }, cancellationToken, IsolationLevel.ReadCommitted);
        }

        public async Task<ItemDetailDto> MoveItemToPalletAsync(int itemId, int targetPalletId, CancellationToken cancellationToken = default)
        {
            // Use serializable isolation level for moving items to prevent conflicts
            return await _transactionManager.ExecuteInTransactionWithIsolationAsync(async (token) =>
            {
                bool canMove = await CanMoveItemToPalletAsync(itemId, targetPalletId, token);
                if (!canMove)
                {
                    throw new DomainException($"Cannot move item {itemId} to pallet {targetPalletId}");
                }

                var item = await _unitOfWork.ItemRepository.GetByIdWithPalletAsync(itemId, token);
                var targetPallet = await _unitOfWork.PalletRepository.GetByIdAsync(targetPalletId, token);

                item.MoveToPallet(targetPallet);

                await _unitOfWork.ItemRepository.UpdateAsync(item, token);

                // Return the updated item
                return await _itemRepository.GetItemDetailByIdAsync(itemId, token);
            }, cancellationToken, IsolationLevel.Serializable);
        }

        public async Task<bool> CanMoveItemToPalletAsync(int itemId, int targetPalletId, CancellationToken cancellationToken = default)
        {
            try
            {
                var item = await _unitOfWork.ItemRepository.GetByIdWithPalletAsync(itemId, cancellationToken);
                if (item == null)
                {
                    return false;
                }

                if (item.Pallet != null && item.Pallet.IsClosed)
                {
                    return false;
                }

                var targetPallet = await _unitOfWork.PalletRepository.GetByIdAsync(targetPalletId, cancellationToken);
                if (targetPallet == null || targetPallet.IsClosed)
                {
                    return false;
                }

                if (item.PalletId == targetPalletId)
                {
                    return false;
                }

                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error checking if item {itemId} can be moved to pallet {targetPalletId}");
                return false;
            }
        }

        public async Task<IEnumerable<ItemListDto>> SearchItemsAsync(string keyword, CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrWhiteSpace(keyword))
            {
                return Enumerable.Empty<ItemListDto>();
            }

            try
            {
                return await _itemRepository.SearchItemsAsync(keyword, cancellationToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error searching items with keyword '{keyword}'");
                throw;
            }
        }

        public async Task<PagedResultDto<ItemListDto>> GetPagedItemsAsync(
            int pageNumber,
            int pageSize,
            int? palletId = null,
            string clientCode = null,
            string manufacturingOrder = null,
            string keyword = null,
            CancellationToken cancellationToken = default)
        {
            try
            {
                return await _itemRepository.GetPagedItemsAsync(
                    pageNumber,
                    pageSize,
                    palletId,
                    clientCode,
                    manufacturingOrder,
                    keyword,
                    true,
                    true,
                    cancellationToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving paged items");
                throw;
            }
        }

        public async Task<PagedResultDto<ItemDetailDto>> GetPagedItemDetailsAsync(
            int pageNumber,
            int pageSize,
            int? palletId = null,
            string clientCode = null,
            string manufacturingOrder = null,
            string keyword = null,
            CancellationToken cancellationToken = default)
        {
            try
            {
                return await _itemRepository.GetPagedItemDetailsAsync(
                    pageNumber,
                    pageSize,
                    palletId,
                    clientCode,
                    manufacturingOrder,
                    keyword,
                    true,
                    true,
                    cancellationToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving paged item details");
                throw;
            }
        }
    }
}

===============================================================================
File: Services\PalletNumberGenerator.cs
===============================================================================
using System;
using System.Linq;
using System.Threading.Tasks;
using PalletManagementSystem.Core.Interfaces.Repositories;
using PalletManagementSystem.Core.Interfaces.Services;
using PalletManagementSystem.Core.Models.Enums;
using PalletManagementSystem.Core.Models.ValueObjects;

namespace PalletManagementSystem.Core.Services
{
    /// <summary>
    /// Service for generating pallet numbers
    /// </summary>
    public class PalletNumberGenerator : IPalletNumberGenerator
    {
        private readonly IPalletRepository _palletRepository;

        /// <summary>
        /// Initializes a new instance of the <see cref="PalletNumberGenerator"/> class
        /// </summary>
        /// <param name="palletRepository">The pallet repository</param>
        public PalletNumberGenerator(IPalletRepository palletRepository)
        {
            _palletRepository = palletRepository ?? throw new ArgumentNullException(nameof(palletRepository));
        }

        /// <inheritdoc/>
        public async Task<PalletNumber> GenerateTemporaryNumberAsync(Division division)
        {
            int sequenceNumber = await _palletRepository.GetNextTemporarySequenceNumberAsync();
            return PalletNumber.CreateTemporary(sequenceNumber, division);
        }

        /// <inheritdoc/>
        public async Task<PalletNumber> GeneratePermanentNumberAsync(Division division)
        {
            int sequenceNumber = await _palletRepository.GetNextPermanentSequenceNumberAsync(division);
            return PalletNumber.CreatePermanent(sequenceNumber, division);
        }

        /// <inheritdoc/>
        public async Task<bool> PalletNumberExistsAsync(string palletNumber)
        {
            return await _palletRepository.ExistsAsync(p => p.PalletNumber.Value == palletNumber);
        }

        /// <inheritdoc/>
        public bool ValidatePalletNumberFormat(string palletNumber, Division division)
        {
            return ValidatePalletNumberFormatInternal(palletNumber, division);
        }

        /// <summary>
        /// Internal static method for validating pallet number format
        /// </summary>
        /// <param name="palletNumber">The pallet number to validate</param>
        /// <param name="division">The division</param>
        /// <returns>True if the format is valid, false otherwise</returns>
        private static bool ValidatePalletNumberFormatInternal(string palletNumber, Division division)
        {
            if (string.IsNullOrWhiteSpace(palletNumber))
                return false;

            // Check if it's a temporary number
            if (palletNumber.StartsWith("TEMP-", StringComparison.OrdinalIgnoreCase))
                return true;

            // Check division-specific format
            switch (division)
            {
                case Division.MA:
                    // Manufacturing: P8 prefix followed by 5 digits
                    return palletNumber.StartsWith("P8") && palletNumber.Length == 7 &&
                           palletNumber.Substring(2).All(char.IsDigit);

                case Division.TC:
                    // Technical Center: 47 prefix followed by 5 digits
                    return palletNumber.StartsWith("47") && palletNumber.Length == 7 &&
                           palletNumber.Substring(2).All(char.IsDigit);

                default:
                    return false;
            }
        }
    }
}

===============================================================================
File: Services\PalletService.cs
===============================================================================
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using PalletManagementSystem.Core.DTOs;
using PalletManagementSystem.Core.Exceptions;
using PalletManagementSystem.Core.Interfaces.Repositories;
using PalletManagementSystem.Core.Interfaces.Services;
using PalletManagementSystem.Core.Models;
using PalletManagementSystem.Core.Models.Enums;
using PalletManagementSystem.Core.Models.ValueObjects;

namespace PalletManagementSystem.Core.Services
{
    public class PalletService : IPalletService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IPalletRepository _palletRepository;
        private readonly IPrinterService _printerService;
        private readonly IPlatformValidationService _platformValidationService;
        private readonly ITransactionManager _transactionManager;
        private readonly ILogger<PalletService> _logger;

        public PalletService(
            IUnitOfWork unitOfWork,
            IPalletRepository palletRepository,
            IPrinterService printerService,
            IPlatformValidationService platformValidationService,
            ITransactionManager transactionManager,
            ILogger<PalletService> logger)
        {
            _unitOfWork = unitOfWork ?? throw new ArgumentNullException(nameof(unitOfWork));
            _palletRepository = palletRepository ?? throw new ArgumentNullException(nameof(palletRepository));
            _printerService = printerService ?? throw new ArgumentNullException(nameof(printerService));
            _platformValidationService = platformValidationService ?? throw new ArgumentNullException(nameof(platformValidationService));
            _transactionManager = transactionManager ?? throw new ArgumentNullException(nameof(transactionManager));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task<PalletListDto> GetPalletByIdAsync(int id, CancellationToken cancellationToken = default)
        {
            return await _palletRepository.GetPalletListByIdAsync(id, cancellationToken);
        }

        public async Task<PalletDetailDto> GetPalletDetailByIdAsync(int id, CancellationToken cancellationToken = default)
        {
            return await _palletRepository.GetPalletDetailByIdAsync(id, cancellationToken);
        }

        public async Task<PalletListDto> GetPalletByNumberAsync(string palletNumber, CancellationToken cancellationToken = default)
        {
            return await _palletRepository.GetPalletListByNumberAsync(palletNumber, cancellationToken);
        }

        public async Task<PalletDetailDto> GetPalletDetailByNumberAsync(string palletNumber, CancellationToken cancellationToken = default)
        {
            return await _palletRepository.GetPalletDetailByNumberAsync(palletNumber, cancellationToken);
        }

        public async Task<IEnumerable<PalletListDto>> GetPalletsByDivisionAndPlatformAsync(
            Division division,
            Platform platform,
            CancellationToken cancellationToken = default)
        {
            bool isValid = await _platformValidationService.IsValidPlatformForDivisionAsync(platform, division);
            if (!isValid)
            {
                throw new ArgumentException($"Platform {platform} is not valid for division {division}");
            }

            return await _palletRepository.GetPalletsByDivisionAndPlatformAsync(division, platform, cancellationToken);
        }

        public async Task<IEnumerable<PalletListDto>> GetPalletsByStatusAsync(
            bool isClosed,
            CancellationToken cancellationToken = default)
        {
            return await _palletRepository.GetPalletsByStatusAsync(isClosed, cancellationToken);
        }

        public async Task<PalletListDto> CreatePalletAsync(
            string manufacturingOrder,
            Division division,
            Platform platform,
            UnitOfMeasure unitOfMeasure,
            string username,
            CancellationToken cancellationToken = default)
        {
            // Use isolation level ReadCommitted for pallet creation
            return await _transactionManager.ExecuteInTransactionWithIsolationAsync(async (token) =>
            {
                bool isValid = await _platformValidationService.IsValidPlatformForDivisionAsync(platform, division);
                if (!isValid)
                {
                    throw new ArgumentException($"Platform {platform} is not valid for division {division}");
                }

                int sequenceNumber = await _palletRepository.GetNextTemporarySequenceNumberAsync(token);
                var palletNumber = PalletNumber.CreateTemporary(sequenceNumber, division);

                var pallet = new Pallet(
                    palletNumber,
                    manufacturingOrder,
                    division,
                    platform,
                    unitOfMeasure,
                    username);

                await _unitOfWork.PalletRepository.AddAsync(pallet, token);

                // Return the created pallet
                return await _palletRepository.GetPalletListByIdAsync(pallet.Id, token);
            }, cancellationToken, IsolationLevel.ReadCommitted);
        }

        public async Task<PalletDetailDto> ClosePalletAsync(
            int palletId,
            bool autoPrint = true,
            CancellationToken cancellationToken = default)
        {
            // Use serializable isolation level for closing pallets to prevent conflicts
            return await _transactionManager.ExecuteInTransactionWithIsolationAsync(async (token) =>
            {
                var pallet = await _unitOfWork.PalletRepository.GetByIdWithItemsAsync(palletId, token);
                if (pallet == null)
                {
                    throw new DomainException($"Pallet with ID {palletId} not found");
                }

                if (pallet.IsClosed)
                {
                    throw new PalletClosedException($"Pallet {pallet.PalletNumber.Value} is already closed");
                }

                PalletNumber permanentNumber = null;
                if (pallet.PalletNumber.IsTemporary)
                {
                    int sequenceNumber = await _palletRepository.GetNextPermanentSequenceNumberAsync(pallet.Division, token);
                    permanentNumber = PalletNumber.CreatePermanent(sequenceNumber, pallet.Division);
                }

                pallet.Close(permanentNumber);

                await _unitOfWork.PalletRepository.UpdateAsync(pallet, token);

                var updatedPallet = await _palletRepository.GetPalletDetailByIdAsync(palletId, token);

                // Print outside the transaction
                if (autoPrint)
                {
                    try
                    {
                        await _printerService.PrintPalletListAsync(pallet.Id);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogWarning(ex, $"Failed to print pallet list for pallet ID {pallet.Id}");
                        // Continue - printing failure shouldn't affect the business operation
                    }
                }

                return updatedPallet;
            }, cancellationToken, IsolationLevel.Serializable);
        }

        public async Task<IEnumerable<PalletListDto>> SearchPalletsAsync(string keyword, CancellationToken cancellationToken = default)
        {
            return await _palletRepository.SearchPalletsAsync(keyword, cancellationToken);
        }

        public async Task<PagedResultDto<PalletListDto>> GetPagedPalletsAsync(
            int pageNumber,
            int pageSize,
            Division? division = null,
            Platform? platform = null,
            bool? isClosed = null,
            string keyword = null,
            CancellationToken cancellationToken = default)
        {
            // Validate platform for division if both are specified
            if (division.HasValue && platform.HasValue)
            {
                bool isValid = await _platformValidationService.IsValidPlatformForDivisionAsync(platform.Value, division.Value);
                if (!isValid)
                {
                    throw new ArgumentException($"Platform {platform} is not valid for division {division}");
                }
            }

            return await _palletRepository.GetPagedPalletsAsync(
                pageNumber,
                pageSize,
                division,
                platform,
                isClosed,
                keyword,
                true,
                true,
                cancellationToken);
        }
    }
}

===============================================================================
File: Services\PlatformValidationService.cs
===============================================================================
using Microsoft.Extensions.Logging;
using PalletManagementSystem.Core.Interfaces.Services;
using PalletManagementSystem.Core.Models.Enums;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace PalletManagementSystem.Core.Services
{
    /// <summary>
    /// Implementation of the platform validation service
    /// </summary>
    public class PlatformValidationService : IPlatformValidationService
    {
        private readonly ILogger<PlatformValidationService> _logger;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlatformValidationService"/> class
        /// </summary>
        /// <param name="logger">The logger</param>
        public PlatformValidationService(ILogger<PlatformValidationService> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <inheritdoc/>
        public Task<bool> IsValidPlatformForDivisionAsync(Platform platform, Division division)
        {
            try
            {
                // This validation logic is simple enough to be fully synchronous
                // but we keep the async signature for consistency with the interface
                bool isValid = IsValidPlatformForDivision(platform, division);
                return Task.FromResult(isValid);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error validating platform {platform} for division {division}");
                throw;
            }
        }

        /// <inheritdoc/>
        public Task<Platform> GetDefaultPlatformForDivisionAsync(Division division)
        {
            try
            {
                Platform defaultPlatform = GetDefaultPlatformForDivision(division);
                return Task.FromResult(defaultPlatform);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error getting default platform for division {division}");
                throw;
            }
        }

        /// <inheritdoc/>
        public Task<IEnumerable<Platform>> GetPlatformsForDivisionAsync(Division division)
        {
            try
            {
                IEnumerable<Platform> platforms = GetPlatformsForDivision(division);
                return Task.FromResult(platforms);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error getting platforms for division {division}");
                throw;
            }
        }

        #region Helper Methods

        /// <summary>
        /// Determines if a platform is valid for a division
        /// </summary>
        private bool IsValidPlatformForDivision(Platform platform, Division division)
        {
            switch (division)
            {
                case Division.MA:
                    return platform == Platform.TEC1 || platform == Platform.TEC2 || platform == Platform.TEC4I;
                case Division.TC:
                    return platform == Platform.TEC1 || platform == Platform.TEC3 || platform == Platform.TEC5;
                default:
                    return false;
            }
        }

        /// <summary>
        /// Gets the default platform for a division
        /// </summary>
        private Platform GetDefaultPlatformForDivision(Division division)
        {
            switch (division)
            {
                case Division.MA:
                case Division.TC:
                    return Platform.TEC1;
                default:
                    return Platform.TEC1;
            }
        }

        /// <summary>
        /// Gets all platforms valid for a specific division
        /// </summary>
        private IEnumerable<Platform> GetPlatformsForDivision(Division division)
        {
            switch (division)
            {
                case Division.MA:
                    return new[] { Platform.TEC1, Platform.TEC2, Platform.TEC4I };
                case Division.TC:
                    return new[] { Platform.TEC1, Platform.TEC3, Platform.TEC5 };
                default:
                    return new[] { Platform.TEC1 };
            }
        }

        #endregion
    }
}

===============================================================================
File: Specifications\BaseSpecification.cs
===============================================================================
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using PalletManagementSystem.Core.Interfaces.Repositories;

namespace PalletManagementSystem.Core.Specifications
{
    /// <summary>
    /// Base class for specifications
    /// </summary>
    /// <typeparam name="T">The entity type</typeparam>
    public abstract class BaseSpecification<T> : ISpecification<T>
    {
        /// <inheritdoc/>
        public Expression<Func<T, bool>> Criteria { get; private set; }

        /// <inheritdoc/>
        public List<Expression<Func<T, object>>> Includes { get; } = new List<Expression<Func<T, object>>>();

        /// <inheritdoc/>
        public List<string> IncludeStrings { get; } = new List<string>();

        /// <inheritdoc/>
        public Expression<Func<T, object>> OrderBy { get; private set; }

        /// <inheritdoc/>
        public Expression<Func<T, object>> OrderByDescending { get; private set; }

        /// <inheritdoc/>
        public bool IsPagingEnabled { get; private set; }

        /// <inheritdoc/>
        public int Skip { get; private set; }

        /// <inheritdoc/>
        public int Take { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="BaseSpecification{T}"/> class
        /// </summary>
        protected BaseSpecification()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BaseSpecification{T}"/> class
        /// </summary>
        /// <param name="criteria">The criteria expression</param>
        protected BaseSpecification(Expression<Func<T, bool>> criteria)
        {
            Criteria = criteria;
        }

        /// <summary>
        /// Adds an include expression to the specification
        /// </summary>
        /// <param name="includeExpression">The include expression</param>
        protected void AddInclude(Expression<Func<T, object>> includeExpression)
        {
            Includes.Add(includeExpression);
        }

        /// <summary>
        /// Adds a string-based include path to the specification
        /// </summary>
        /// <param name="includeString">The include string</param>
        protected void AddInclude(string includeString)
        {
            IncludeStrings.Add(includeString);
        }

        /// <summary>
        /// Applies paging to the specification
        /// </summary>
        /// <param name="skip">The number of entities to skip</param>
        /// <param name="take">The number of entities to take</param>
        protected void ApplyPaging(int skip, int take)
        {
            Skip = skip;
            Take = take;
            IsPagingEnabled = true;
        }

        /// <summary>
        /// Applies ascending ordering to the specification
        /// </summary>
        /// <param name="orderByExpression">The ordering expression</param>
        protected void ApplyOrderBy(Expression<Func<T, object>> orderByExpression)
        {
            OrderBy = orderByExpression;
        }

        /// <summary>
        /// Applies descending ordering to the specification
        /// </summary>
        /// <param name="orderByDescendingExpression">The ordering expression</param>
        protected void ApplyOrderByDescending(Expression<Func<T, object>> orderByDescendingExpression)
        {
            OrderByDescending = orderByDescendingExpression;
        }
    }
}

===============================================================================
File: Specifications\ByIdSpecification.cs
===============================================================================
using System;
using System.Linq.Expressions;

namespace PalletManagementSystem.Core.Specifications
{
    /// <summary>
    /// A specification for filtering entities by ID
    /// </summary>
    /// <typeparam name="T">The entity type</typeparam>
    public class ByIdSpecification<T> : BaseSpecification<T> where T : class
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ByIdSpecification{T}"/> class
        /// </summary>
        /// <param name="id">The entity ID</param>
        public ByIdSpecification(int id)
            : base(CreateIdPredicate(id))
        {
        }

        /// <summary>
        /// Creates a predicate expression to filter by ID
        /// </summary>
        /// <param name="id">The ID to filter by</param>
        /// <returns>A predicate expression</returns>
        private static Expression<Func<T, bool>> CreateIdPredicate(int id)
        {
            // Use reflection to get the Id property
            var parameter = Expression.Parameter(typeof(T), "x");
            var property = Expression.Property(parameter, "Id");
            var value = Expression.Constant(id);
            var equals = Expression.Equal(property, value);
            return Expression.Lambda<Func<T, bool>>(equals, parameter);
        }
    }
}

===============================================================================
File: Specifications\PagedSpecification.cs
===============================================================================
namespace PalletManagementSystem.Core.Specifications
{
    /// <summary>
    /// A specification for paging
    /// </summary>
    /// <typeparam name="T">The entity type</typeparam>
    public class PagedSpecification<T> : BaseSpecification<T>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PagedSpecification{T}"/> class
        /// </summary>
        /// <param name="pageNumber">The page number (1-based)</param>
        /// <param name="pageSize">The page size</param>
        public PagedSpecification(int pageNumber, int pageSize)
        {
            // Skip (pageNumber - 1) * pageSize items and take pageSize items
            ApplyPaging((pageNumber - 1) * pageSize, pageSize);
        }
    }
}

===============================================================================
File: Specifications\SpecificationBuilder.cs
===============================================================================
using System;
using PalletManagementSystem.Core.Interfaces.Repositories;

namespace PalletManagementSystem.Core.Specifications
{
    /// <summary>
    /// Utility class for creating specifications
    /// </summary>
    public static class SpecificationBuilder
    {
        /// <summary>
        /// Creates a specification for an entity by ID
        /// </summary>
        /// <typeparam name="T">The entity type</typeparam>
        /// <param name="id">The entity ID</param>
        /// <returns>The specification</returns>
        public static ISpecification<T> ById<T>(int id) where T : class
        {
            return new ByIdSpecification<T>(id);
        }

        /// <summary>
        /// Creates a specification for paging
        /// </summary>
        /// <typeparam name="T">The entity type</typeparam>
        /// <param name="pageNumber">The page number (1-based)</param>
        /// <param name="pageSize">The page size</param>
        /// <returns>The specification</returns>
        public static ISpecification<T> Paged<T>(int pageNumber, int pageSize) where T : class
        {
            // Create a specification that applies paging
            return new PagedSpecification<T>(pageNumber, pageSize);
        }
    }
}
